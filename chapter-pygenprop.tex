\chapter{Development of a Python library for programmatic exploration and comparison of organism Genome Properties}

Introduction text..

\section{Parsing the Genome Properties Database}

The Genome Properties database consists of a series of flat files, whose individual property records are not indexed or connected. In all use cases, Pygenprop requires the information found within the Genome Properties database to perform its job. Before this information can be used by the library, it must be loaded into main memory.  The intent of Pygenprop's parser is to read the database files from disk, load them into main memory, build connections between records found within and present the information contained to the rest of the library. 

\subsection{Overview of the Genome Properties flat file database and associated file formats}

The Genome Properties database currently consists of a series of flat files which are hosted inside a Github Repository (see URL). Information about both public and non-public properties are hosted under this repository's \textbf{data} folder. Each property is assigned a single file folder which contains three files. A \textbf{DESC} file, which contains information about the property; a \textbf{status} file which contains information onto whether the property is public or has been manually curated; and a \textbf{FASTA} file, for properties whose steps are supported by InterProScan signatures, which contain representative protein sequences for each step of the property. In addition to the per-property folders contained within the repository's  \textbf{data} folder, there is also a Genome Properties release file located in the \textbf{flatfiles} folder which also contains Genome Properties information. Specifically, this file, called \textbf{genomeProperties.txt}, is a concatenation of the \textbf{DESC} files for all public properties found in the repositories \textbf{data} folder and is created with each release of the Genome Properties database on Github. Below is simplified a folder structure for the Genome Properties Github repository.

\begin{verbatim}
├── code/ - # Contains the Genome Properties Perl library.
├── data/ - # Data about both public and private properties
│   ├── GenProp0001/
│   │   ├── DESC - # Detailed property information
│   │   ├── FASTA - # Example sequences of proteins that carry out each step of the property
│   │   └── status - # Contains public and manual curation statuses
│   └── GenProp0002/
│       ├── DESC
│       ├── FASTA
│       └── status
└── flatfiles/
    └── genomeProperties.txt
\end{verbatim}

Pygenprop contains a parser for parsing both the \textbf{DESC} files of single singular property folders and the concatenated \textbf{genomeProperties.txt} file. The format of each \textbf{DESC} file is very similar to the Stockholm sequence alignment format used by both the Pfam and Rfam databases \cite{bateman2004pfam, griffiths2003rfam} and as such the format consists of key value pairs. However, since these files use different keys than Stockholm a custom parser had to be developed. It is of note that the Genome Properties database format wraps every eighty characters. Thus, some key types which contain long sentences will be repeated for multiple lines.  Below is an example \textbf{DESC} file and a summary of key types can be found in Table \ref{table:property-file-keys}.

\begin{verbatim}
AC  GenProp0145
DE  Histidine degradation to glutamate
TP  PATHWAY
AU  Haft DH
TH  2
RN  [1]
RM  2203753
RT  Nucleotide sequence of the gene encoding the repressor for the
RT  histidine utilization genes of Pseudomonas putida.
RA  Allison SL, Phillips AT;
RL  J Bacteriol. 1990;172:5470-5476.
RN  [2]
RM  25559274
RT  Structure of N-formimino-L-glutamate iminohydrolase from Pseudomonas 
RT  aeruginosa.
RA  Fedorov AA, Martí-Arbona R, Nemmara VV, Hitchcock D, Fedorov EV, Almo SC, 
RA  Raushel FM;
RL  Biochemistry. 2015;54(3):890-7.
DC  Histidine Catabolism
DR  IUBMB; AminoAcid; His3;
DC  Histidine Metabolism
DR  KEGG; map00340;
DC  L-histidine degradation II
DR  MetaCyc; PWY-5028;
CC  This pathway is involved in histidine utilization system (hut). HutP is
CC  the first gene in the hut operon encoding the hutHUIG operator and a
CC  positive regulator of the operon, activated allostatically in the
CC  presence of L-histidine. HutC represses histidine utilization by binding 
CC  the regulatory sites for hutHUIG and hutF [1]. There are multiple
CC  variations in the histidine degradation pathway, including two possible 
CC  routes for the first step (either via histidine transaminase, or as in 
CC  this pathway, via histidine ammonia-lyase/histidase). L-histidine is 
CC  first converted to urocanate by hutH (histidine ammonia-lyase), which is 
CC  then converted to 4-imidazolone-5-propionate by hutU (urocanate 
CC  hydratase), and finally hydrolysed to N-formimino-L-glutamate by hutI 
CC  (imidazolonepropionate amidohydrolase). From here there are three 
CC  potential paths to glutamate. This property refers to the two-step 
CC  process found in some bacteria where N-formimino-L-glutamate is first 
CC  converted to N-formyl-l-glutamate by hutF (formimidoylglutamate 
CC  deiminase) and then hydrolyzed to L-glutamate by hutG 
CC  (N-formyl-l-glutamate deformylase)[2].
**  Evidence for steps 4 and 5 is the same.
--
SN  1
ID  Histidine ammonia-lyase (hutH)
DN  Histidine ammonia-lyase/hutH (EC 4.3.1.3)
RQ  1
EV  IPR005921; TIGR01225; sufficient;
TG  GO:0006548;
--
SN  2
ID  Urocanate hydratase (hutU)
DN  Urocanate hydratase/hutU (EC 4.2.1.49)
RQ  1
EV  IPR023637; TIGR01228; sufficient;
TG  GO:0006548;
--
SN  3
ID  Imidazolonepropionase (hutI)
DN  Imidazolonepropionase/hutI (EC 3.5.2.7)
RQ  1
EV  IPR005920; TIGR01224; sufficient;
TG  GO:0006548;
--
SN  4
ID  Formimidoylglutamate deiminase/formiminoglutamase/glu-formyltransferase
DN  Formimidoylglutamate deiminase/hutF (EC 3.5.3.13)
RQ  1
EV  IPR005923; TIGR01227; sufficient;
TG  GO:0006548;
EV  IPR010252; TIGR02022; sufficient;
TG  GO:0006548;
EV  IPR004227; TIGR02024; sufficient;
TG  GO:0006548;
--
SN  5
ID  Formylglutamate deformylase/formiminoglutamase/glu-formyltransferase
DN  N-formylglutamate deformylase/hutG (EC 3.5.1.68)
RQ  1
EV  IPR005923; TIGR01227; sufficient;
TG  GO:0006548;
EV  IPR010247; TIGR02017; sufficient;
TG  GO:0006548;
EV  IPR004227; TIGR02024; sufficient;
TG  GO:0006548;
--
SN  6
ID  Histidine utilization repressor (hutC)
DN  Histidine utilization repressor/hutC
RQ  0
EV  IPR010248; TIGR02018; sufficient;
//
\end{verbatim}

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|}
\caption{Genome Properties DESC files use a variety of keys to provide information about a single property. Note that this table is copied form the Genome Properties database documentation (see \href{https://genome-properties.readthedocs.io/en/latest/flatfile.html\#desc-file}{https://genome-properties.readthedocs.io/en/latest/flatfile.html\#desc-file}).}
\label{table:property-file-keys}\\
\hline
\textbf{Key} & \textbf{Information Type} \\ \hline
\endfirsthead
%
\multicolumn{2}{c}%
{{\bfseries Table \thetable\ continued from previous page}} \\
\hline
\textbf{Key} & \textbf{Information Type} \\ \hline
\endhead
%
AC & Accession ID \\ \hline
DE & Description/name of Genome Property \\ \hline
TP & Type \\ \hline
AU & Author \\ \hline
TH & Threshold \\ \hline
RN & Reference number \\ \hline
RM & PMID of reference \\ \hline
RT & Reference title \\ \hline
RA & Reference author \\ \hline
RL & Reference citation \\ \hline
DC & Database title \\ \hline
DR & Database link \\ \hline
PN & Parent accession ID \\ \hline
CC & Property description \\ \hline
** & Private notes \\ \hline
– & Separator \\ \hline
SN & Step number \\ \hline
ID & Step ID \\ \hline
DN & Step display name (includes EC number if available) \\ \hline
RQ & Required step \\ \hline
EV & Evidence (includes whether sufficient) \\ \hline
TG & Gene Ontology (GO) ID \\ \hline
// & End \\ \hline
\end{longtable}

\subsection{Parser Implementation}

Pygenprop's Genome Properties flat file parser can parse both single property \textbf{DESC} files and \textbf{genomeProperties.txt} database release files which contain information about multiple properties. It reads these files one line at a time to decrease memory usage, allowing for compatibility with low memory machines and increases in database size. While loading line by line, lines for each property are loaded into a Python list as they are encountered. Once a list for a single property is full, the key types which can take up multiple lines, such as property descriptions (see Table \ref{table:property-file-keys} and example file above), are collapsed to single key value pairs. These collapsed key-value pairs are then iterated and the data inside are used to create a series of in-memory objects representing the property. As individual property objects are created they are added to a list. Once parsing is completed, the parser places this list in a Genome Property Tree object which represents the connections in the database's DAG structure. This object is then returned from the parser.

\subsection{Parser Performance}

Pygenprop's Genome Properties flat file parser was found to be able to parse single \textbf{DESC} files in 415 µs ± 5.59 µs on average and the latest release of the entire Genome Properties database (\textbf{genomeProperties.txt} of release 2.0) in 242 ms ± 4.81 ms (using a Macbook Pro 13-inch, Late 2013 with an Intel Intel Core i5 2.4 GHz processor). Since most applications of the parser will involve only parsing the database once, this speed was determined to be sufficient. If a greater speed is required, for example if the genome properties database grows greatly in size, the parser could be sped up by using software such as Cython \cite{behnel2010cython} or Numba \cite{lam2015numba} to transpile the existing Python code to C \cite{kernighan2006c}. Alternatively, the parser could be rewritten in C or C++ \cite{ISO:1998:IIP} from scratch and integrated into the existing Python code via CPython's  C extension interface \cite{van1995python}. If the machine that Pygenprop is running on is I/O bound, other solution may be required such as storing the Genome Properties database in a Random-access memory (RAM) disk or on a Solid-state drive (SSD). \\

\section{Development of an object oriented class framework for the representation of the Genome Properties database}

As discussed in the previous chapter, the Genome Properties database consists of series of interdependent genome properties representing both metabolic and structural features of cells. Some properties are used as evidence of others forming parent child relationships between properties and an overall rooted directed acyclic graph structure (DAG). After parsing the Genome Properties database, Pygenprop instantiates a series of objects representing that information contained within the database (see Table \ref{tab:database-objects}, Fig. \ref{fig:property} and Fig. \ref{fig:propertytree}). These objects are connected to each other in linked list fashion where objects point to each othe. These connections are doubly linked facilitating climbing both up and down the genome properties DAG and between genome property, step, functional element and evidence objects (Fig. \ref{fig:property} and Fig. \ref{fig:propertytree}). Individual methods and attributes of these objects can be used in software applications or used interactively in Jupyter Notebooks \cite{kluyver2016jupyter}. The below subsections detail the Genome Properties database classes and how they can be used. 

\begin{longtable}{|p{4cm}|p{11cm}|}
\caption{A summary of the object types used to represent the Genome Properties database.}
\label{tab:database-objects}\\
\hline
\textbf{Object Type} & \textbf{Description}                                                                          \\ \hline
\endfirsthead
%
\multicolumn{2}{c}%
{{\bfseries Table \thetable\ continued from previous page}} \\
\hline
\textbf{Object Type} & \textbf{Description}                                                                          \\ \hline
\endhead
%
Tree                 & Encapsulates a DAG of genome property objects                                                 \\ \hline
Genome Property      & Represents an individual genome property                                                      \\ \hline
Literature Reference & Represents an article discussing a genome property                                            \\ \hline
Database Reference   & Represents a record in an external pathways database which is equivalent to a genome property \\ \hline
Step                 & Represents a step supporting the existence of a genome property                               \\ \hline
Functional Element   & Represents a functional element supporting the existence of a step                            \\ \hline
Evidence             & Represents an evidence supporting the existence of a functional element                       \\ \hline
\end{longtable}

\begin{figure}[!ht]
     \centering
	\includegraphics[width=0.90\textwidth]{media/Figure_1A.eps}
	 \caption{Some property objects are the children of others. Database reference, literature reference and step objects are children of property objects. Figure is from  \cite{bergstrand2019pygenprop}.}
	  \label{fig:propertytree}
\end{figure}

\begin{figure}[!ht]
     \centering
	\includegraphics[width=0.90\textwidth]{media/Figure_1B.eps}
	 \caption{Each property is supported by step, functional element, and evidence objects. Figure is from  \cite{bergstrand2019pygenprop}.}
	  \label{fig:property}
\end{figure}

\subsection{The Genome Property Class}

The genome property class creates a blueprint for objects which represent individual genome properties. Instantiated objects possess methods, properties (attributes whose return value is generated by a function), and attributes which represents data about the property contained in the property \textbf{DESC} file. Information about property steps, database references and literature references have been abstracted into their own classes. A summary of the methods, properties and attributes of genome property objects can be seem in Table \ref{tab:genome-property-object} and example code below.

\begin{longtable}{|p{2.7cm}|p{2cm}|p{10cm}|}
\caption{A list of methods, properties and attributes of genome property objects.}
\label{tab:genome-property-object}\\
\hline
\textbf{Name} & \textbf{Type} & \textbf{Description} \\ \hline
\endfirsthead
%
\multicolumn{3}{}%
{{\bfseries Table \thetable\ continued from previous page}} \\
\hline
\textbf{Name} & \textbf{Type} & \textbf{Description} \\ \hline
\endhead
%
required\_steps & Property & Return a list of step objects representing steps which are required to support the existence of the property \\ \hline
child\_genome \_property \_identifiers & Property & Return a list of the genome property identifiers of child genome properties which are used as step evidences for the property \\ \hline
to\_json & Method & Serialize the property to a JSON string \\ \hline
databases & Attribute & A list of database objects representing external database references to the property \\ \hline
references & Attribute & A list of literature reference objects representing external articles discussing the property \\ \hline
private\_notes & Attribute & Private internal notes about the property \\ \hline
tree & Attribute & The genome property tree for to which the property belongs \\ \hline
description & Attribute & A complete description for the property \\ \hline
threshold & Attribute & The minimum number of required steps for to which must be assigned YES in order for the property to be assigned PARTIAL rather than NO support during property assignment \\ \hline
type & Attribute & The type of property (e.g. GUILD, CATEGORY, PATHWAY, etc.) \\ \hline
steps & Attribute & A list of step objects representing all steps that can support the existence of the property (including non-required) \\ \hline
public & Attribute & True if the property is publicly released \\ \hline
children & Attribute & A list of child genome property objects representing properties the are used as step evidences by the property \\ \hline
name & Attribute & The name of the property \\ \hline
id & Attribute & The genome property identifier (e.g. GenPropXXXX) \\ \hline
parents & Attribute & A list of parent genome properties objects representing properties that use the property as step evidences \\ \hline
\end{longtable}

\subsubsection{Example code for using genome property objects}

\begin{lstlisting}[language=Python]

property.id
Out: 'GenProp0144'
	
property.name
Out: 'Chlorophyllide a biosynthesis from protoporphyrin IX'

property.parents
Out: List of parent property objects

property.children	
Out: List of child property objects

property.steps
Out: List of step objects		
	
property.databases
Out: List of database reference objects

property.references
Out: List of literature reference objects

\end{lstlisting}

\subsection{The Database Reference Class}

The database reference class allows for the creation of objects which map the property to equivalent records in other databases such as KEGG and Metacyc. They are children of genome property objects. A summary of the methods, properties and attributes of database reference objects can be seem in Table \ref{tab:database-reference-object} and example code below.

\begin{longtable}{|p{2.7cm}|p{2cm}|p{10cm}|}
\caption{A list of methods, properties and attributes of database reference objects.}
\label{tab:database-reference-object}\\
\hline
\textbf{Name}  & \textbf{Type} & \textbf{Description}                                                                       \\ \hline
\endfirsthead
%
\multicolumn{3}{c}%
{{\bfseries Table \thetable\ continued from previous page}} \\
\hline
\textbf{Name}  & \textbf{Type} & \textbf{Description}                                                                       \\ \hline
\endhead
%
database\_name & Attribute     & The name of the database in questions (e.g. KEGG)                                          \\ \hline
record\_title  & Attribute     & The name of the record in the external database for which the property is equivalent       \\ \hline
record\_ids    & Attribute     & The identifier of the record in the external database for which the property is equivalent \\ \hline
\end{longtable}

\subsubsection{Example code for using database reference objects}

\begin{lstlisting}[language=Python]

reference = property.databases[0]
	
reference.database_name
Out: 'MetaCyc'

reference.record_title
Out: 'Pathway: 3,8-divinyl-chlorophyllide a biosynthesis III'

# Returns a list to handle cases where there are multiple identifiers.
reference.record_ids[0] 
Out: 'PWY-7159'

\end{lstlisting}

\subsection{The Literature Reference Class}

The literature reference class lays out the foundation for objects which represent specific articles which support the existence of the property. They are children of genome property objects. A summary of the methods, properties and attributes of literature reference objects can be seem in Table \ref{tab:literature-reference-object} and example code below.

\begin{longtable}{|p{2.7cm}|p{2cm}|p{10cm}|}
\caption{A list of methods, properties and attributes of literature reference objects.}
\label{tab:literature-reference-object}\\
\hline
\textbf{Name} & \textbf{Type} & \textbf{Description}                   \\ \hline
\endfirsthead
%
\multicolumn{3}{c}%
{{\bfseries Table \thetable\ continued from previous page}} \\
\hline
\textbf{Name} & \textbf{Type} & \textbf{Description}                   \\ \hline
\endhead
%
number        & Attribute     & The number of the reference            \\ \hline
pubmed\_id    & Attribute     & The PUBMED identifier of the reference \\ \hline
title         & Attribute     & The title of the literature reference for the property             \\ \hline
authors       & Attribute     & The authors of the literature reference for the property           \\ \hline
citation      & Attribute     & A citation for the literature reference for the property           \\ \hline
\end{longtable}

\subsubsection{Example code for using literature reference objects}

\begin{lstlisting}[language=Python]

reference = property.references[0]
	
reference.pubmed_id
Out: '17370354'

reference.title
Out: 'Recent advances in chlorophyll biosynthesis.'

reference.citation
Out: 'Photosynth Res. 2006;90(2):173-194.'

\end{lstlisting}

\subsection{The Step Class}

The step class is used to generate objects representing individual genome property steps. They are children of parent genome properties. They also have functional elements as children. A summary of the methods, properties and attributes of step objects can be seem in Table \ref{tab:step-object} and example code below.

\begin{longtable}{|p{2.7cm}|p{2cm}|p{10cm}|}
\caption{A list of methods, properties and attributes of step objects.}
\label{tab:step-object}\\
\hline
\textbf{Name}           & \textbf{Type} & \textbf{Description}                                                                                                                   \\ \hline
\endfirsthead
%
\multicolumn{3}{c}%
{{\bfseries Table \thetable\ continued from previous page}} \\
\hline
\textbf{Name}           & \textbf{Type} & \textbf{Description}                                                                                                                   \\ \hline
\endhead
%
name                    & Property      & Return the name of the step                                                                                                                   \\ \hline
required                & Property      & Return true if the step is required for assignment of the parent genome property                                                              \\ \hline
property \_identifiers   & Property      & Return a list of genome property identifiers of genome properties which are used as evidence for the step                                     \\ \hline
interpro \_identifiers   & Property      & Return a list of InterPro identifiers which are used as evidence for the step (e.g. IPRXXXX)                                                  \\ \hline
consortium \_identifiers & Property      & Return a list of InterPro consortium member database (e.g. PFAM) signature identifiers which are used as evidence for the step (e.g. PFXXXXX) \\ \hline
genome \_properties      & Property      & Return a list of child genome property objects which are used as evidence for the step                                                        \\ \hline
number                  & Attribute     & The number of the step                                                                                                                 \\ \hline
parent                  & Attribute     & The parent genome property of the step                                                                                                 \\ \hline
functional \_elements    & Attribute     & A list of functional elements which are used to support the existence a step                                                           \\ \hline
\end{longtable}

\subsubsection{Example code for using step objects}

\begin{lstlisting}[language=Python]

step = property.steps[0]
	
step.number
Out: '1'

step.name
Out: 'Magnesium-chelatase subunit ChlD (EC 6.6.1.1)'

step.required
Out: 'True'

step.interpro_identifiers
Out: 'A list of InterPro identifiers (e.g. IPR011776)'

step.consortium_identifiers 
Out: 'A list of consortium signature identifiers (e.g. TIGR02031)'

step.functional_elements
Out: 'A list of functional element objects'

\end{lstlisting}

\subsection{The Functional Element Class}

The functional element class allows for the instantiation of objects which are placed between step object and evidence objects during parsing. Functional elements are not part of the original genome properties database schema and were added by Pygenprop to take into account for certain steps which can be catalysed by multiple enzyme families. For example, it is common that under anoxic conditions organisms will use a different set of enzymes to catalyze a step in a biochemical pathway due to the lack of oxygen present to support the reaction. This issue of having multiple types of enzymes being able to catalyze a step is an open issue on the Genome Properties database Github (see \href{https://github.com/ebi-pf-team/genome-properties/issues/29}{https://github.com/ebi-pf-team/genome-properties/issues/29}). The addition of functional elements is designed to address this issue.  A summary of the methods, properties and attributes of functional element objects can be seem in Table \ref{tab:element-object} and example code below.

\begin{longtable}{|p{2.7cm}|p{2cm}|p{10cm}|}
\caption{A list of methods, properties and attributes of functional element objects.}
\label{tab:element-object}\\
\hline
\textbf{Name} & \textbf{Type} & \textbf{Description}                                                                    \\ \hline
\endfirsthead
%
\multicolumn{3}{c}%
{{\bfseries Table \thetable\ continued from previous page}} \\
\hline
\textbf{Name} & \textbf{Type} & \textbf{Description}                                                                    \\ \hline
\endhead
%
parent        & Attribute     & The step object for to which the functional element supports                            \\ \hline
evidence      & Attribute     & A list of evidence objects that support the existence of the functional element         \\ \hline
name          & Attribute     & The name of the functional element                                                      \\ \hline
id            & Attribute     & The identifier of the functional element                                                \\ \hline
required      & Attribute     & True if the functional element is required for assignment of the parent genome property \\ \hline
\end{longtable}

\subsubsection{Example code for using functional element objects}

\begin{lstlisting}[language=Python]

element = step.functional_elements[0]
	
element.id
Out: 'element.id'

element.name
Out: 'Magnesium-chelatase subunit ChlD (EC 6.6.1.1)'

element.required
Out: 'True'

element.evidence
Out: 'A list of evidence objects'

\end{lstlisting}

\subsection{The Evidence Class}

The evidence class allows for the generations of objects which represent individual pieces of evidence which support the existence of functional elements and in turn genome property steps. Pieces of evidence include the presence of InterPro consortium signatures or support for existence of other genome properties found in an organism's genome.  A summary of the methods, properties and attributes of evidence objects can be seem in Table \ref{tab:element-object} and example code below.

\begin{longtable}{|p{2.7cm}|p{2cm}|p{10cm}|}
\caption{A list of methods, properties and attributes of evidence objects.}
\label{tab:evidence-object}\\
\hline
\textbf{Name}           & \textbf{Type} & \textbf{Description}                                                                                                                                \\ \hline
\endfirsthead
%
\multicolumn{3}{c}%
{{\bfseries Table \thetable\ continued from previous page}} \\
\hline
\textbf{Name}           & \textbf{Type} & \textbf{Description}                                                                                                                                \\ \hline
\endhead
%
has\_genome \_property   & Property      & Return true if the evidence is supported by the existence a genome property                                                                                \\ \hline
property \_identfiers    & Property      & Return a list of genome property identifiers of genome properties which are used by the evidence                                                           \\ \hline
interpro \_identifiers   & Property      & Return a list InterPro identifiers of genome properties which are used by this evidence (e.g. IPRXXXX)                                                     \\ \hline
consortium \_identifiers & Property      & Return a list of InterPro consortium member database (e.g. PFAM) signature identifiers of genome properties which are used by this evidence (e.g. PFXXXXX) \\ \hline
genome \_properties      & Property      & Return a list of child genome property objects which are used by this evidence                                                                             \\ \hline
parent                  & Attribute     & The parent functional element of this evidence                                                                                                      \\ \hline
gene\_ontology \_terms   & Attribute     & The GO term identifiers associated with the InterPro identifiers which are used by the evidence                                                     \\ \hline
evidence \_identifiers   & Attribute     & A list of both InterPro and signature identifiers used by the evidence                                                                              \\ \hline
sufficient              & Attribute     & True if the evidence alone can prove the existence of a functional element                                                                          \\ \hline
\end{longtable}

\subsubsection{Example code for using evidence objects}

\begin{lstlisting}[language=Python]

evidence = element.evidence[0]
	
evidence.has_genome_property
Out: 'false'

evidence.sufficient
Out: 'true'

evidence.interpro_identifiers
Out: 'A list of InterPro identifiers (e.g. IPR011776)'

evidence.consortium_identifiers 
Out: 'A list of consortium signature identifiers (e.g. TIGR02031)'

\end{lstlisting}

\subsection{The Genome Properties Tree Class}

Genome properties tree objects, as instantiated from the genome properties tree class, represent the rooted DAG structure of entire Genome Properties database. even though the Genome Properties database is actually a rooted DAG, the name 'tree' is used for the class and tree terminology is used in the object's methods for end user convenience. A rooted DAG is not a tree as its branches can merge together unlike those of a true tree. Tree objects contains a Python dictionary of genome property objects indexed by their property identifiers. In addition, individual property objects point to each other using their child and parent (Fig. \ref{fig:propertytree} and Table \ref{tab:genome-property-object}). These child-parent relationships between property objects are built the genome properties tree object's instantiation. The genome properties tree class allows users to search for specific genome properties, and find root and leaf properties. A summary of the methods, properties and attributes of tree objects can be seem in Table \ref{tab:tree-object} and example code below.

\begin{longtable}{|p{2.7cm}|p{2cm}|p{10cm}|}
\caption{A list of methods, properties and attributes of tree objects.}
\label{tab:tree-object}\\
\hline
\textbf{Name}                               & \textbf{Type} & \textbf{Description}                                                                                                                                                                                                                                                            \\ \hline
\endfirsthead
%
\multicolumn{3}{c}%
{{\bfseries Table \thetable\ continued from previous page}} \\
\hline
\textbf{Name}                               & \textbf{Type} & \textbf{Description}                                                                                                                                                                                                                                                            \\ \hline
\endhead
%
build\_genome \_property \_connections        & Method        & Iterate through every genome property which is a child of the tree; set these property's parent and child attributes to point to child and parent property objects which are also children of the tree. This method connects property objects to create a rooted DAG structure. \\ \hline
to\_json                                    & Method        & Serialize the property tree to a JSON string                                                                                                                                                                                                                                    \\ \hline
create \_metabolism \_database \_mapping\_file & Method        & Write a CSV file which maps from genome property identifiers to the identifiers of equivelent records found in KEGG and Metacyc                                                                                                                                                 \\ \hline
root                                        & Property      & The genome property who has no parent.                                                                                                                                                                                                                                          \\ \hline
leafs                                       & Property      & Return a list of genome property objects whose steps are not supported by other genome properties                                                                                                                                                                               \\ \hline
genome \_property \_identifiers               & Property      & Return a list of the genome property identifiers (e.g. GenPropXXXX) for all genome properties within the database                                                                                                                                                               \\ \hline
interpro \_identifiers                       & Property      & Return a list of InterPro identifiers which are used as evidence for all steps (e.g. IPRXXXX) within the database                                                                                                                                                               \\ \hline
consortium \_identifiers                     & Property      & Return a list of InterPro consortium member database (e.g. PFAM) signature identifiers which are used as evidence for the step (e.g. PFXXXXX) within the database                                                                                                               \\ \hline
consortium \_identifiers \_dataframe          & Property      & Return the above in the form of a pandas DataFrame                                                                                                                                                                                                                              \\ \hline
genome \_properties \_dictionary              & Attribute     & A dictionary of genome property objects representing all genome properties within by the database; dictionary is keyed by genome property identifier                                                                                                                            \\ \hline
\end{longtable}

\subsubsection{Example code for using genome property tree objects}

\begin{lstlisting}[language=Python]

tree = GenomePropertyTree(*property_object_list)
tree_two = parse_genome_properties_flat_file(genome_properties_file_handle)
	
len(tree)  # number of properties in the database
Out: 'false'

tree.root
Out: 'The root genome property object'

tree.leafs
Out: 'A list of leaf genome property objects (those with no child properties)'

for genome_property in tree:  # Properties in the tree can be iterated.
	print(genome_property.id)
Out: 'Prints all genome property identifiers'

tree['GenProp1127'] # The tree can be rapidly searched
Out: 'The genome property object representing GenProp1127.'

\end{lstlisting}

\subsection{Performance of Pygenprop's Genome Properties database representation}

Pygenprop's representation of the Genome Properties database (Version 2.0), a genome properties tree object and its children, takes only up 11.16 MB of random-access memory. This in contrast to the database's original \textbf{genomeProperties.txt} file which takes up only 1.76 MB on disk. The memory usage difference is due the representation of the database as a series of objects and their associated data structures. However, since 11.16 MB is still takes up little memory on a modern machine, more compact data representations for Genome Properties data were not pursued. The size of the database, and its read-only use case, allows for its storage in main memory rather than in an on-disk database such as SQLite \cite{owens2006definitive} or PostgreSQL \cite{momjian2001postgresql}.

Individual genome property objects can be looked up, by property identifier, from within a genome properties tree object within 277 ns ± 7.91 ns. This speed is due property objects being stored within a Python dictionary. Python dictionaries are implemented a hash tables, allowing for quick look ups \cite{van1995python}.

\section{Assignment of Properties to Organism Genomes}

Information contained within the Genome Properties database can be used to assign YES, NO or PARTIAL support for an organism possessing a genetically-derived property such as a biochemical pathway. These assignments of YES, NO or PARTIAL are based on the the presence of InterPro consortium database signatures (e.g PFAMs, TIGRFAMS, etc.) present in protein domain annotations on an organism's genome. These domain annotations are generated by InterProScan \cite{jones2014interproscan}. Some genome properties, in addition to the above signatures, rely on the previous assignments of support for child genome properties for their own assignment. Pygenprop's code for assigning genome properties is based on that of the Genome Properties Perl library (see https://github.com/ebi-pf-team/genome-properties) that ships along side the Genome Properties database. It replicates the library's assignment functionality. Pygenprop assigns properties support from leaf to root using a recursive algorithm (\ref{fig:propertyassignment}). Assignment starts with step evidences and flows up through functional elements and steps and eventually to individual properties (Fig. \ref{fig:propertyassignment}). The rules used for assigning support at different levels are detailed in the subsections below. For each organism that needs to be to have properties assigned an Assignment Cache object is created. This object contains all data required for property assignment and methods for assigning support for properties using this data. A detailed description of this class is also found in the subsections below.

\begin{figure}[!ht]
     \centering
	\includegraphics[width=0.90\textwidth]{media/Pygenprop_Assignment.pdf}
	 \caption{An overview of the genome property assignment process used by Pygenprop.}
	  \label{fig:propertyassignment}

\end{figure}

\subsection{The Assignment Cache Class}

Assignment cache objects, insatiated from the assignment cache class, are used to assign genome properties to an organism or metagenome. They can be generated from InterProScan TSV files (protein domain annotation files created by a user), lists of InterPro member database signature identifiers (as could be downloaded from precalculated InterProScan results for UniProt proteomes \cite{uniprot2014uniprot}), or pre-calculated property assignment files previously generated by the Genome Properties Perl library. In the case of InterProScan files, only a deduplicated version of the file's consortium signature identifier column is used. The TSV files are parsed using pandas and pre-calculated property assignment files are parsed using a custom parser. Assignment cache objects contain two dictionaries for storing previously calculated property and step assignments, respectively. It also contains a Set which is designed to store all InterPro consortium signature identifiers found for an organism's protein domain annotations. The assignment cache has a method called \textbf{bootstrap\_assignments} which is use a genome property tree (see Table \ref{tab:tree-object}) object and data stored within itself to calculate all property assignments for an organism. Multiple assignment caches from multiple organisms can be combined together during the creation of assignment results objects that allow comparison of properties between organisms. A summary of the methods, properties and attributes of assignment cache objects can be seem in Table \ref{tab:tree-object} and example code below.

\begin{longtable}{|p{2.7cm}|p{2cm}|p{10cm}|}
\caption{A list of methods, properties and attributes of assignment cache objects.}
\label{tab:assignment-cache-object}\\
\hline
\textbf{Name} & \textbf{Type} & \textbf{Description} \\ \hline
\endfirsthead
%
\multicolumn{3}{c}%
{{\bfseries Table \thetable\ continued from previous page}} \\
\hline
\textbf{Name} & \textbf{Type} & \textbf{Description} \\ \hline
\endhead
%
cache\_property \_assignment & Method & Add a property assignment to the cache \\ \hline
get\_property \_assignment & Method & Return a property assignment from the cache \\ \hline
cache\_step \_assignment & Method & Add a step assignment to the cache \\ \hline
get\_step \_assignment & Method & Retrun a step assignment from the cache \\ \hline
flush\_property \_from\_cache & Method & Remove a property assignment and its associated step assignments from the cache \\ \hline
synchronize \_with\_tree & Method & If a property whose assignment is cached is not found in the tree, remove the assignment and its associated step assignments. This method allows for compatibility between different Genome Properties database versions and pre-calculated assignments. \\ \hline
bootstrap \_assignments & Method & Recursively assign support for properties from leaf to root using an internal set pre-calculated assignments and a InterPro consortium signature identifiers. \\ \hline
bootstrap \_missing\_step \_assignments & Method & Search through a genome property tree to find steps which are not in the cache. Assign these steps NO since they are missing. This method is used when pre-calculated step assignments which result in NO have been omitted to save disk space. \\ \hline
create \_results\_tables & Method & Return two pandas DataFrames representing property and step assignments for the organism \\ \hline
property \_identifiers & Property & Return a list of genome property identifiers (e.g. GenPropXXXX) for properties whose assignment are in the cache \\ \hline
property \_assignments & Attribute & A dictionary of YES, NO and PARTIAL labeled property assignments keyed by genome property identifier. \\ \hline
step \_assignments & Attribute & A doubly nested dictionary of YES, and NO labeled step assignments keyed by genome property identifier and step number. \\ \hline
interpro \_signiture \_accessions & Attribute & A set of InterPro consortium signature identifiers of domains found in the organism's protein domain annotations. \\ \hline
sample\_name & Attribute & The name of the organism or sample. When the assignment cache is created from a file, the sample name is set to the filename without file extension. \\ \hline
\end{longtable}

\subsubsection{Example code for using genome property tree objects}

\begin{lstlisting}[language=Python]
tree = parse_genome_properties_flat_file(genome_properties_file_handle)

cache1 = parse_genome_property_longform_file(pre_calculated_file_handle)
cache2 = parse_interproscan_file(interproscan_tsv_file_handle)
cache3 = AssignmentCache(sample_name='E_coli', 
interpro_signature_accessions=identifier_list)

cache2.sample_name
Out: 'C_benthia_SPR155'

cache2.get_property_assignment('GenProp1065')
Out: 'PARTIAL'

cache2.get_step_assignment('GenProp1067', 2) 
Out: 'YES'

# Set GenProp2536 to YES
cache2.cache_property_assignment('GenProp2536', 'YES')

# Set GenProp2539 step two to YES
cache2.cache_step_assignment('GenProp2539', 2, 'YES')

# Remove GenProp2567 from the cache
cache2.flush_property_from_cache('GenProp2567')

# Bootstrap both step and property assignments
cache2.boostrap_assignments(properties_tree=tree)

# Create pajndas DataFrames for per organism property and step assignments
tables = cache2.create_results_tables(properties_tree=tree)
property_table = tables[0]
step_table = tables[1]

\end{lstlisting}

\subsection{The Assignment Algorithms}

As mentioned above, Pygenprop use recursion, the process of functions calling themselves, to assign YES, NO and PARTIAL support for individual properties found within the genome properties database. During assignment recursion, Pygenprop uses a genome properties tree object to provide it with information about assignment requirements and connections between individual genome properties. In the context of assignment cache objects, the support assignment process is referred to as bootstrapping assignments. This is because properties are assigned from a mixture of existing informations such as pre-calculated assignments and InterPro consortium signatures found in an organism's domain annotations. Like in the algorithms used in the Genome Properties Perl library, both properties and steps are given assignments and step assignment are used to assign support for parent properties. It is of note that, during the recursion process, that newly calculated step and property assignments are added to the assignment cache object's step and property assignment dictionaries. Successive recursive assignment calculates check these dictionaries first, using the \textbf{get\_property\_assignment} and  \textbf{get\_step\_assignment} methods, to find step and property assignment which have already been calculated. Since the Genome Properties database forms a rooted DAG, branches in the parent-child property relationships can merge. Thus there will be property assignments to retrieve from the cache as they have already been calculated in previous recursions. In addition, the step and assignment cache dictionaries can be filled with pre-calculated assignments from a file or database. The use of an assignment caching, allows for the assignment process to increase in speed up exponentially as more properties are calculated. Assignments which are already cached are taken as gospel and recursion stops when they are collected from the cache. Recursion also stops when step assignments are calculated for steps which are not supported by the assignment of other genome properties. 

\subsubsection{Assignment of steps, functional elements and evidences}

Step assignments are calculated recursively from functional element and evidence assignments (Fig. \ref{fig:propertyassignment}). Evidences are assigned YES or NO based on the presence an InterPro consortium signature found in the assignment cache's \textbf{interpro \_signiture \_accessions} set (Table \ref{tab:assignment-cache-object}) or a recursively calculated property assignment. The signature identifier or child property to be used specified inside evidence's representative evidence object (Table \ref{tab:evidence-object}) inside the genome property tree object passed to the cache's \textbf{bootstrap\_assignments} function. Evidence are assigned NO if they are not found in the cache's \textbf{interpro \_signiture \_accessions} attribute and YES otherwise. If the evidence is supported by the support assignment of another genome property, then the evidence is only assigned YES if the genome property's assignment is YES or PARTIAL (Fig. \ref{fig:propertyassignment}).  Functional elements are assigned YES under two situations: If all underlying evidences have been assigned YES or if a single evidence which sufficient on its own to support the existence of a step is assigned YES (Fig. \ref{fig:propertyassignment}). For example, if As mentioned in Table \ref{tab:evidence-object}, some evidences can be used as the sole piece of evidence for a step. Other than these two situations the functional element is assigned NO. Steps are assigned YES or NO based off the assignments of functional elements (Fig. \ref{fig:propertyassignment}). Steps are assigned YES only if all functional elements of that step have been assigned YES and are assigned NO otherwise. As noted in the above section, assignment results for already calculated steps are checked for before step assignment recursion and are added to the cache after step assignment calculations. If an evidence has a genome property as its child, this property's assignment is calculated creating another recursion cascade.

\subsubsection{Assignment of non-categorical properties}

Some properties have steps which are required to exist for the property to be assigned YES or PARTIAL. In addition each property is given a \textbf{threshold} attribute (Table \ref{tab:genome-property-object}) which specifies how many required steps must be present before an assignment of PARTIAL support can be applied to the property. If their are required steps for a property, as specified by information contained in a genome property object in the genome property tree, the genome property can only be assigned YES if all required properties are present (Fig. \ref{fig:propertyassignment}). The property is assigned PARTIAL if the number of its required steps assigned YES is greater than its required steps threshold attribute (Fig. \ref{fig:propertyassignment}). If the number of required steps assigned YES is less than or equal to the required steps threshold then the property is assigned NO support. It is important to note that genome property support assignment does note take into account steps which are optional, only those which are required. As noted in the above section, assignment results for already calculated properties are checked for before property assignment recursion and are added to the cache after property assignment calculations. If a property's step's assignment value is not known it is calculated causing a recursion cascade.

\subsubsection{Assignment of categorical properties}

Categorical properties, such as GenProp0065 Metabolism, do not have any required steps. All steps are optional. Thus a different algorithm is required for their assignment. Categorical properties are only assigned YES if all steps are assigned YES, NO if all steps are assigned NO and PARTIAL otherwise (Fig. \ref{fig:propertyassignment}). Note that the generation of support assignments for categorical properties is unique to Pygenprop and is not performed by the Genome Properties Perl library. The recursion in the Perl library stops before it reaches categorical properties.

\subsection{Assignment Performance}

For a 2.93 MB InterProScan TSV file containing domain annotations for 4100 \textit{Escherichia\ coli }K12 proteins, the resulting assignment cache object was found to be 1.16 MB of main memory before bootstrapping assignments and 1.71 MB after. Assignment bootstrapping was found to take 76.7 ± 15.41 ms for K12 (using a Macbook Pro 13-inch, Late 2013 with an Intel Intel Core i5 2.4 GHz processor). Thus, Pygenprop could calculate property assignments for thousands genomes in only a few minutes. This speed was found to be sufficient. However, further performance gains could be made in the future if assignments were stored inside pandas DataFrames \cite{mckinney2010data} similar to those created by an assignment cache object's \textbf{create\_results\_tables} method (Table \ref{tab:assignment-cache-object}), rather than a Python dictionary.

\section{Development of a Representation for Comparing Genome Property Assignments Across Multiple Organisms}

One of the main goals of Pygenprop was to facilitate comparison of the presence/absence of biochemical pathways across organism. In addition, Pygenprop is designed to support making these comparisons programmatically. Specifically, it is designed to provide methods to filter out properties which are shared between organisms to highlight differences in metabolic or functional capabilities across organisms. Having programmatic access to these difference and having them in computationally accessible form will allow future researchers to automate many aspects of pathway analysis, such as complex phenotype prediction and prediction of niche partitioning in the case of microbial ecology contexts.

\subsection{The Assignment Results Class}

To support programmatic exploration of genome properties assignments Pygenprop includes the Assignment Results class.  Objects of this class takes a series of Assignment Cache objects (Table \ref{tab:assignment-cache-object}), potentially from disparate sources, as input during their instantiation (Fig. \ref{fig:resultscreation}). The per-sample assignments found within these caches are then combined into a multiple sample form. Specifically, they are stored in two indexed pandas DataFrames \cite{mckinney2010data}: One for property level assignments and another for step level assignments. Within these DataFrames, assignments are stored in compact NumPy arrays \cite{van2011numpy}. In addition, to these two DataFrames the assignment results class contains a series of functions for filtering down step and property assignments.  A summary of the methods, properties and attributes of assignment results objects can be seem in Table \ref{tab:results-object} and example code below.

\begin{figure}[!ht]
     \centering
	\includegraphics[width=0.90\textwidth]{media/assignment_results_overview.pdf}
	 \caption{Assignment results objects are created by combining the assignment caches generate for multiple organisms. These caches can be from disparate sources such as InterProScan results files or lists of InterPro signatures provided by an remote server.}
	  \label{fig:resultscreation}
\end{figure}

\begin{longtable}{|p{2.7cm}|p{2cm}|p{10cm}|}
\caption{A list of methods, properties and attributes of assignment results objects.}
\label{tab:results-object}\\
\hline
\textbf{Name} & \textbf{Type} & \textbf{Description} \\ \hline
\endfirsthead
%
\endhead
%
get\_results & Method & Return the assignment results as a pandas DataFrame for a series of genome properties at either a step or property level \\ \hline
get\_results \_summary & Method & Return a summary of assignment results as a pandas DataFrame for a series of genome properties a either a step or property level \\ \hline
get\_property \_results & Method & Return a list of assignments of support for all samples for a given property \\ \hline
get\_step\_results & Method & Return a list of assignments for all samples for a given property step \\ \hline
to\_json & Method & Serialize the results object as a JSON property tree with results for each sample annotating each property node \\ \hline
to\_assignment \_database & Method & Serialize the results object to a SQLite database file (.micro) \\ \hline
sample\_names & Property & Return the names of all samples used in the creation of the results object. \\ \hline
differing \_property \_results & Property & Return a pandas DataFrame of property assignments with properties whose assignments are the same across all samples filtered out \\ \hline
differing\_step \_results & Property & Return a pandas DataFrame of step assignments with steps whose assignments are the same across all samples filtered out \\ \hline
supported \_property \_results & Property & Return a pandas DataFrame of property assignments with properties whose assignments are NO across all samples filtered out \\ \hline
supported\_step \_results & Property & Return a pandas DataFrame of step assignments with steps whose assignments are NO across all samples filtered out \\ \hline
property\_results & Attribute & A pandas DataFrame of property assignments across all samples \\ \hline
step\_results & Attribute & A pandas DataFrame of step assignments across all samples \\ \hline
tree & Attribute & The genome properties tree object used during instantiation of the results object \\ \hline
\end{longtable}

\subsubsection{}

TODO

\subsection{The choice of pandas for compatibility with the Python Data Science and Machine Learning Software Stack}

Pandas is a Python library for cleaning, filtering and reshaping data. It presents data to users as a DataFrame, in other words a two dimentional data matrix with both column and row names. Pandas dataframe's allow user's to index columns, supporting the rapid joining of datasets. During data analysis it is common to join DataFrames together creating joint datasets. Pandas DataFrames were designed to provide Python with similar functionality to the builtin dataframes presented by other data analysis languages such as R \cite{rprogman}. Both pandas DataFrame objects contained within an assignment results object are built on top of NumPy arrays \cite{mckinney2010data}. NumPy arrays are a compact memory format designed to support vectorized mathematical calculations on both numeric and string data \cite{van2011numpy}. They are roughly equivalent to R vectors \cite{rprogman}. NumPy arrays are used extensively across the entire Python data science stack \cite{scipystack}. This software stack is called SciPy.

Pygenprop presents property and step assignments as pandas DataFrames inside of an assignment results object. These DataFrames allows users to easily query and filter assignments using pandas idioms, and join these assignments to pre-existing metadata.  For example, gene expression data (microarray or transcriptomic), culture optimal growth conditions or even host environmental conditions. Once these datasets are joined they can be co-visualized, using libraries such as Bokeh (cite XXX) and Seaborn (cite YYY), to help with pattern discovery. Bokeh can even be used to generate data visualization dashboards (small websites which present pre-built charts) that other researchers can use. These dashboards are equivalant to R's Shiny apps. These joined datasets provide great potential as a source of data for data mining or as training sets for machine learning algorithms. Specifically the NumPy arrays inside pandas DataFrames can easily be transferred to machine learning libraries in the SciPy ecosystem such as SciKit-learn (cite XXX), PyTourch (cite xxx) and Tensorflow (cite xxx). Scikit-learn can be used to cluster the above joint data to mine for patterns of interest as well as build machine learning classifiers which can make predictions based on genome properties assignments. Examples of classifier provided by Scikit-learn include Support Vector Machine (SVM) and Random Forests classifiers.

\subsection{Assignment Results Performance}

TODO

\section{Extension of the assignment cache and assignment results class to include supporting match information}

A motif is a discrete pattern in a protein's sequence which are often associated with the existence of a protein domain. A protein domain is conserved part of a protein's sequence which carries out a specific function and are evolutionarily conserved. These domains often generate their own discrete three dimensional structures during protein folding. Domain annotation is the process of predicting the placement and function of domains in protein sequences. During genomic analysis it common practice to perform domain annotation on an organism's predicted proteins.

Domain annotations of an organism's proteins are created by finding similarities between motifs in an organism's proteins and previously seen motifs of domains from other proteins found in a protein database. If an organism and database motif are highly similar in sequence they are said to form a match. The quality of this match can be quantified by a variety of metrics such as expected value (E-value) score (how likely is the match given the chance of finding a similar motif randomly in one of the organism's proteins) or alignment length (how much of the motif in the protein aligns with the motif in the database). If it is determined that that a match is of high quality, the motif in the organism's protein can be assigned the same name and function as the original domain that the motif in the database.

One tool for performing domain annotation of an organism's proteins is InterProScan which predicts both the type and placement of domains in an organism's proteins and also provides supporting match information to justify its predictions. This supporting information includes E-value scores and predicted motif start and stop points for matches between motifs in the protein and motifs associated with domains catalogued in InterPro consortium databases. The domain annotations and match information are stored in an InterProScan TSV file. InterProScan takes a FASTA file containing an organism's predicted proteins as input.

As mentioned in previous sections, Genome properties are assigned from InterProScan domain annotations of an organism's proteins. These annotations are provided in the above TSV. Specifically predictions of the existence of domains which can be used, either singly or in consort, to uniquely identify enzymes or protein structures which act as evidence for genome property steps. It may be the case that domains used as genome property step evidence's will be found in more than one protein of an organism and some of these proteins may be false positives which may posses the identifying domain (or a similar domain) but do not carry out the genome property step. To filter out these false positives, researchers often want direct access to the match information held within the InterProScan file so they can use it to further filter matches. Alternatively, users may want access to the entire sequence of proteins containing matches so they can be further analysed. For example, the proteins which are predicted to possess a step evidence domain could be compared phyogenetically to reference proteins which are already known carry out a property step in other organisms.

Previously with the Genome Properties Perl library, the information required to perform the above analyses were kept in four separate file types: property information was kept in a \textbf{genomeProperties.txt} file, assignment information was kept in per-organism long-form property assignment files, protein sequences were kept in per-organism FASTA files and domain annotations are per-organism InterProScan TSV files. If one wanted to find proteins or match information that supported the existence of a genome property step they would have to write a script to parse all four of these files types, combine the data contained within each and perform searches on this data. These scripts would be difficult and time consuming to write as there would be much boiler plate code to be written just for join the information found before analysis. Since above file types are created per-organism, if one wanted to apply such scripts to multiple organisms then these scripts would have to be able to remember which file, and the data held within, belongs to what organism. This tracking would further complicate script development.

Much of the aforementioned boiler plate code has already been integrated into Micromeda. For example, code for parsing the Genome Properties database and the generation of assignment result objects for comparing the presence/absence of genome properties across organisms. To make it easier for users to access match information for proteins which are annotated to have putative domains which support the existence of genome property steps, Pygenprop contains extend versions of both property cache and assignment results classes. These extended versions contain attributes, properties and methods related to accessing supporting match information.

\subsection{Considerations for retention of match information}

Pygenprop can generate pathway annotation files called Micromeda files (see section XXX). These files not only contain property and step assignments for multiple organisms but also contain information supporting the creation of these assignments such as InterProScan match information and protein sequences. However, both FASTA files and InterProScan TSV files, which Micromeda files are ultimately built from, contain information about proteins and domains, respectively, which do not support the existence of genome property steps. Retention of this information is superfluous to the goal of providing supporting information for genome property steps, and would ultimately bloat the file size of the Micromeda files. Thus, in Micromeda files,  only retain domain annotations and protein sequences for genome property steps which are assigned YES. In addition, these files only retain E-value scores for domain annotations, and not other types of match metrics, for similar space savings reasons. Since Micromeda files are essentially serializations of assignment results with matches objects, these objects also only retain match information and protein sequences which support genome property steps which are assigned YES. 

Note that only retaining match information and sequences which support steps which are assigned YES generates a corner case. This corner case can be found when a step is which is supported by more than one evidence and is ultimately assigned NO support and one of the evidences is assigned YES (Fig. \ref{fig:propertyassignment}). In this case, the match information supporting the step evidence assigned YES is dropped from the Micromeda files and assignment cache with matches objects since its parent step has been assigned NO. The choice to not retain supporting informations for all evidence assigned YES was made in order to reduce the complexity and memory requirements of Micromeda files and is based on the assumption that researchers would rarely look at evidence level supporting information for genome property steps assigned No.

\subsection{The assignment cache with matches class}

TODO: This needs a figure.

The assignment cache with matches class extends the assignment cache class via class inheritance. In addition to the attributes, properties and methods inherited from the assignment cache class, it also possesses new attributes, properties and methods related to storing match information, E-value scores and protein sequences, which support the existence of genome property steps. Step match information is stored in a pandas DataFrame within each instantiated assignment cache with matches object. These objects are generated from parsing a FASTA file (cite XXX) of an organism's protein encoded open reading frames (ORFs) (cite XXX) and an InterProScan TSV of domain annotations of these ORFs. This parsing begins with the TSV file being parsed using pandas and the protein identifier, consortium signature identifier, E-value score columns being extracted. Each row of the resulting pandas DataFrame corresponds to a protein domain annotation: the identifier of a protein in the FASTA file, the identifier of the matched InterPro consortium signature found in this protein, and the E-value score of that match. The FASTA file is then parsed using Scikit-bio's FASTA file parser (cite XXX). Scikit-bio is a Python bioinformatics library which uses NumPy arrays to store sequence data. The use of NumPy arrays allows it to have superior performance, in terms of memory usage and sequence string manipulation to competing bioinformatics libraries such a BioPython. Once parsed by Scikit-bio, the FASTA sequences are converted to a pandas DataFrame consisting of a column of protein identifiers and a column of coresponding protein sequences from the original FASTA file. This sequence DataFrame is then merged with the above domain annotation DataFrame on their protein identifier column creating a third unified DataFrame that is added to an instantiating assignment cache with matches object. This parsing process creates one assignment cache with matches objects per pair of FASTA file and corosponding InterProScan TSV file. A summary of the methods, properties and attributes of assignment cache with matches objects can be seem in Table \ref{tab:results-object} and example code below.

\subsection{The assignment results with matches class}

The assignment results with matches class extends the assignment result class via class class inheritance. In addition to the attributes, properties and methods inherited from the assignment results class, it also possesses new attributes, properties and methods related to storing match information, E-value scores and protein sequences, which support the existence of genome property steps. Assignment results with matches classes are generated by combining a series of assignment cache with matches objects. Specifically, it combines the matches attribute of each input assignment cache with matches object and index them by sample name, genome property and step columns allowing cross organism comparisons. The assignment results with matches class provides a variety of convince functions for accessing match information such as 