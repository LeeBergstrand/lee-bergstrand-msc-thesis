\chapter{Development of a Python library for Programmatic Exploration and Comparison of Organism Genome Properties} \label{Pygenprop}

During the development of Micromeda's server component, we recognized that it would be useful to have a software library to assist with programmatic usage of the Genome Properties database. This library would be used to access the database's information, assign levels of support to individual properties and compare these assignments between organisms. A vital component of the thesis work was the development of this library, called Pygenprop \cite{bergstrand2019pygenprop}. Pygenprop is a Python library that provides an object-oriented framework \cite{booch1986object} for representing the Genome Properties database and assessing the property assignments of multiple organisms. It is deeply integrated with the Python data science software stack \cite{scipystack} through its representation of property assignments as pandas DataFrames \cite{mckinney2010data}. It is also interoperable with modern machine learning frameworks, opening up new use cases for pathway annotation data. Pygenprop additionally provides automation features for tracking the data used to generate property assignments and storing assignments for later use. Pygenprop was recently published in Oxford Bioinformatics \cite{bergstrand2019pygenprop}. In this chapter, we will review the structure and function of Pygenprop's core modules and the design decisions implemented during its creation.

\section{Parsing the Genome Properties Database}

Before addressing the object-oriented programming aspects of Pygenprop, it is important to first discuss how it ingests data. In all use cases, Pygenprop requires the information found within the Genome Properties database and before the library can use this information, it must first be loaded into a computer's main memory (random-access memory or RAM). This parsing of the Genome Properties database is the job of Pygenprop's Genome Properties database parser.

The Genome Properties database consists of a series of flat files. The database parser module loads these files from disk and encodes the information contained within them in a tree-like data structure. The layout of this data structure is detailed in the next section. A secondary goal of the parser is to build connections between individual properties as the database consists of a series of flat files, whose individual property records are not indexed nor connected. 

\subsection{Overview of the Genome Properties Flat File Database and Associated File Formats} \label{Genome-Properties-Files} \label{genome-properties-files}

The Genome Properties database (as of version 2.0) consists of a series of flat files that are hosted inside a Github repository (see \href{github.com/ebi-pf-team/genome-properties}{github.com/ebi-pf-team/genome-properties}). Information about individual properties is stored in the repository's \textbf{data} folder, and within this folder, each property is assigned a second internal folder containing three files: 
\begin{itemize}
\item A \textbf{DESC} file, that contains information about the property
\item A \textbf{status} file that contains information onto whether the property is public or has been manually curated
\item A \textbf{FASTA} \cite{pearson19905} file containing representative protein sequences that carry out the steps a the property
\end{itemize}
The \textbf{data} folder contains information about both public and non-public genome properties. 

In addition to the per-property folders, there is also a Genome Properties release file located in the \textbf{flatfiles} folder of the repository that also contains Genome Properties information. Specifically, this file, called \textbf{genomeProperties.txt}, is a concatenation of all the \textbf{DESC} files of all public properties. This file is created with each new release of the Genome Properties database on Github. Below is simplified a folder structure for the Genome Properties Github repository.

\begin{verbatim}
├── code/ - # The Genome Properties Perl library.
├── data/ - # Data about both public and private properties
│ ├── GenProp0001/
│ │ ├── DESC - # Detailed property information
│ │ ├── FASTA - # Sequences of proteins that carry out steps
│ │ └── status - # Public and manual curation status
│ └── GenProp0002/
│  ├── DESC
│  ├── FASTA
│  └── status
└── flatfiles/
 └── genomeProperties.txt
\end{verbatim}

The Genome Properties database parser is capable of parsing both single \textbf{DESC} files of individual properties and the concatenated \textbf{genomeProperties.txt} release file. The format of \textbf{DESC} files is very similar to the Stockholm sequence alignment format used by both the Pfam and Rfam databases \cite{bateman2004pfam, griffiths2003rfam}. Like these file types, \textbf{DESC} files consist of a series of key-value pairs. Because these files use different keys than Stockholm, a custom parser had to be developed. It is of note that the Genome Properties database format wraps every eighty characters. Thus, some key types that contain long sentences are repeated for multiple lines and the parser must unwrap these lines to prevent parsing errors. Below is an example \textbf{DESC} file and a summary of key types can be found in Table \ref{table:property-file-keys}.

\begin{verbatim}
AC GenProp0145
DE Histidine degradation to glutamate
TP PATHWAY
AU Haft DH
TH 2
RN [1]
RM 2203753
RT Nucleotide sequence of the gene encoding the repressor for the
RT histidine utilization genes of Pseudomonas putida.
RA Allison SL, Phillips AT;
RL J Bacteriol. 1990;172:5470-5476.
RN [2]
RM 25559274
RT Structure of N-formimino-L-glutamate iminohydrolase from Pseudomonas 
RT aeruginosa.
RA Fedorov AA, Martí-Arbona R, Nemmara VV, Hitchcock D, Fedorov EV, Almo SC, 
RA Raushel FM;
RL Biochemistry. 2015;54(3):890-7.
DC Histidine Catabolism
DR IUBMB; AminoAcid; His3;
DC Histidine Metabolism
DR KEGG; map00340;
DC L-histidine degradation II
DR MetaCyc; PWY-5028;
CC This pathway is involved in histidine utilization system (hut). HutP is
CC the first gene in the hut operon encoding the hutHUIG operator and a
CC positive regulator of the operon, activated allostatically in the
CC presence of L-histidine. HutC represses histidine utilization by binding 
CC the regulatory sites for hutHUIG and hutF [1]. There are multiple
CC variations in the histidine degradation pathway, including two possible 
CC routes for the first step (either via histidine transaminase, or as in 
CC this pathway, via histidine ammonia-lyase/histidase). L-histidine is 
CC first converted to urocanate by hutH (histidine ammonia-lyase), that is 
CC then converted to 4-imidazolone-5-propionate by hutU (urocanate 
CC hydratase), and finally hydrolysed to N-formimino-L-glutamate by hutI 
CC (imidazolonepropionate amidohydrolase). From here there are three 
CC potential paths to glutamate. This property refers to the two-step 
CC process found in some bacteria where N-formimino-L-glutamate is first 
CC converted to N-formyl-l-glutamate by hutF (formimidoylglutamate 
CC deiminase) and then hydrolyzed to L-glutamate by hutG 
CC (N-formyl-l-glutamate deformylase)[2].
** Evidence for steps 4 and 5 is the same.
--
SN 1
ID Histidine ammonia-lyase (hutH)
DN Histidine ammonia-lyase/hutH (EC 4.3.1.3)
RQ 1
EV IPR005921; TIGR01225; sufficient;
TG GO:0006548;
--
SN 2
ID Urocanate hydratase (hutU)
DN Urocanate hydratase/hutU (EC 4.2.1.49)
RQ 1
EV IPR023637; TIGR01228; sufficient;
TG GO:0006548;
--
SN 3
ID Imidazolonepropionase (hutI)
DN Imidazolonepropionase/hutI (EC 3.5.2.7)
RQ 1
EV IPR005920; TIGR01224; sufficient;
TG GO:0006548;
--
SN 4
ID Formimidoylglutamate deiminase/formiminoglutamase/glu-formyltransferase
DN Formimidoylglutamate deiminase/hutF (EC 3.5.3.13)
RQ 1
EV IPR005923; TIGR01227; sufficient;
TG GO:0006548;
EV IPR010252; TIGR02022; sufficient;
TG GO:0006548;
EV IPR004227; TIGR02024; sufficient;
TG GO:0006548;
--
SN 5
ID Formylglutamate deformylase/formiminoglutamase/glu-formyltransferase
DN N-formylglutamate deformylase/hutG (EC 3.5.1.68)
RQ 1
EV IPR005923; TIGR01227; sufficient;
TG GO:0006548;
EV IPR010247; TIGR02017; sufficient;
TG GO:0006548;
EV IPR004227; TIGR02024; sufficient;
TG GO:0006548;
--
SN 6
ID Histidine utilization repressor (hutC)
DN Histidine utilization repressor/hutC
RQ 0
EV IPR010248; TIGR02018; sufficient;
//
\end{verbatim}

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|}
\caption{Genome Properties \textbf{DESC} files use a variety of keys to provide information about a single property. The below table is copied from the Genome Properties database \href{genome-properties.readthedocs.io/en/latest/flatfile.html\#desc-file}{documentation}.}
\label{table:property-file-keys}\\
\hline
\textbf{Key} & \textbf{Information Type} \\ \hline
\endfirsthead
%
\multicolumn{2}{c}%
{{\bfseries Table \thetable\ continued from previous page}} \\
\hline
\textbf{Key} & \textbf{Information Type} \\ \hline
\endhead
%
AC & Accession ID \\ \hline
DE & Description/name of Genome Property \\ \hline
TP & Type \\ \hline
AU & Author \\ \hline
TH & Threshold \\ \hline
RN & Reference number \\ \hline
RM & PMID of reference \\ \hline
RT & Reference title \\ \hline
RA & Reference author \\ \hline
RL & Reference citation \\ \hline
DC & Database title \\ \hline
DR & Database link \\ \hline
PN & Parent accession ID \\ \hline
CC & Property description \\ \hline
** & Private notes \\ \hline
– & Separator \\ \hline
SN & Step number \\ \hline
ID & Step ID \\ \hline
DN & Step display name (includes EC number if available) \\ \hline
RQ & Required step \\ \hline
EV & Evidence (includes whether sufficient) \\ \hline
TG & Gene Ontology (GO) ID \\ \hline
// & End \\ \hline
\end{longtable}

\subsection{Parser Implementation}

The database parser reads both \textbf{DESC} and \textbf{genomeProperties.txt} files one line at a time to decrease memory usage. This parsing method allows for compatibility with low memory machines and increases in database size that are greater than a computer's main memory. While loading line by line, lines are split into key-value pairs and loaded into a Python list as they are encountered. Once all keys for a single property are found, the key-value pairs for key types that can take up multiple lines, such as property descriptions (see Table \ref{table:property-file-keys} and example file above), are collapsed to single pairs. These collapsed key-value pairs and those remaining uncollapsed are then used to create a series of in-memory Python objects representing a single property. In the case of \textbf{genomeProperties.txt} files, Pygenprop repeats this process for all property record in the file, creating a second list of \textbf{GenomeProperty} objects. \footnote{Note that we use capital letter notation to visually separate objects and classes from the concepts they represent. For example \textbf{GenomeProperty} objects represent individual genome properties and \textbf{Step} objects represent individual property steps.} Once parsing is completed, this list is used to create a \textbf{GenomePropertiesTree} object that represents the database's rooted Directed Acyclic Graph structure. The parser then returns this object.

\subsection{Parser Performance}

Pygenprop's Genome Properties flat file parser processes a single \textbf{DESC} file in 415 µs \textpm 5.59 µs on average and the latest release of the entire Genome Properties database (the \textbf{genomeProperties.txt} of release 2.0) in 242 ms \textpm 4.81 ms \footnote{Note that for the remainder of the document, unless otherwise noted, all performance tests were done on a Macbook Pro 13-inch, Late 2013 with an Intel Core i5-4258U 2.4 GHz processor (2 cores, 4 threads, 3 MB L3 cache), 16 GB of RAM and a 256 GB PCIe SSD.} Since most applications of the parser will involve only parsing the database once, this speed was determined to be sufficient. If a higher speed is required, for example if the genome properties database grows substantially in size, the parser could be sped up by using software such as Cython \cite{behnel2010cython} or Numba \cite{lam2015numba} to transpile the existing Python code to C \cite{kernighan2006c}. Alternatively, the parser could be rewritten in C or C++ \cite{ISO:1998:IIP} and integrated into the existing Python code via CPython's C extension interface \cite{van1995python}. If the machine that Pygenprop is running on is Input/Output (I/O) bound, other solutions may be required, such as storing the Genome Properties database in a random-access memory (RAM) disk or on a solid-state drive (SSD).

\section{Development of an Object-Oriented Class Framework for the Representation of the Genome Properties Database} \label{genomeprop-oop}

As discussed in the previous chapter, the Genome Properties database consists of a series of interdependent genome properties representing both metabolic and structural features of cells. Some properties are used as evidence of others, forming parent-child relationships between properties and an overall rooted directed acyclic graph (DAG) structure across the database. Pygenprop follows an object-oriented programming paradigm \cite{booch1986object} (see \href{en.wikipedia.org/wiki/Object-oriented\_programming}{en.wikipedia.org/wiki/Object-oriented\_programming}) and thus after parsing the Genome Properties database, Pygenprop represents the database as a series of in-memory objects (see Table \ref{tab:database-objects}, and Fig. \ref{fig:propertytree}) that contain information about individual properties (Fig. \ref{fig:property}). These objects are connected in a linked list fashion \cite{newell1957programming} (see \href{en.wikipedia.org/wiki/Linked\_list}{en.wikipedia.org/wiki/Linked\_list}), where objects point to each other. These connections are doubly linked, which enables climbing both up and down the DAG and between GenomeProperty, Step, FunctionalElement and Evidence objects (Fig. \ref{fig:property} and Fig. \ref{fig:propertytree}). Methods and attributes of these objects can be used in software applications or explored interactively in Jupyter Notebooks \cite{kluyver2016jupyter}. The below subsections detail Pygenprop's Genome Properties database classes and how they can be used. 

\begin{longtable}{|p{4cm}|p{11cm}|}
\caption{A summary of the object types used to represent the Genome Properties database.}
\label{tab:database-objects}\\
\hline
\textbf{Object Type} & \textbf{Description}                   \\ \hline
\endfirsthead
%
\multicolumn{2}{c}%
{{\bfseries Table \thetable\ continued from previous page}} \\
\hline
\textbf{Object Type} & \textbf{Description}                   \\ \hline
\endhead
%
Tree     & Encapsulates a DAG of genome property objects             \\ \hline
Genome Property  & Represents an individual genome property              \\ \hline
Literature Reference & Represents an article discussing a genome property           \\ \hline
Database Reference & Represents a record in an external pathway database that is equivalent to a genome property \\ \hline
Step     & Represents a step supporting the existence of a genome property        \\ \hline
Functional Element & Represents a functional element supporting the existence of a step       \\ \hline
Evidence    & Represents an evidence supporting the existence of a functional element      \\ \hline
\end{longtable}

\begin{figure}[!ht]
  \centering
	\includegraphics[width=0.90\textwidth]{media/Figure_1A.eps}
	 \caption{Some property objects are the children of others. Database reference, literature reference and step objects are children of property objects. Figure is from \cite{bergstrand2019pygenprop}.}
	 \label{fig:propertytree}
\end{figure}

\begin{figure}[!ht]
  \centering
	\includegraphics[width=0.90\textwidth]{media/Figure_1B.eps}
	 \caption{Each property is supported by step, functional element and evidence objects. Figure is from \cite{bergstrand2019pygenprop}.}
	 \label{fig:property}
\end{figure}

\subsection{The GenomeProperty Class} \label{genome-property-class}

The GenomeProperty class creates a blueprint for objects that represent individual genome properties. Once instantiated, these objects possess properties (i.e., attributes whose return value is generated by a function) and attributes that represent data about the property. This information mirrors that provided in the genome property's \textbf{DESC} file before parsing. These objects also provide methods that may be useful for end-users, such as serializing the GenomeProperty object to a JavaScript Object Notation (JSON) \cite{bray2014rfc} string. Information about property steps, database references and literature references have been abstracted into seperate classes. A summary of the methods, properties and attributes of GenomeProperty objects can be seen in Table \ref{tab:genome-property-object} and example code below.

\begin{longtable}{|p{2.7cm}|p{2cm}|p{10cm}|}
\caption{The methods, properties and attributes of GenomeProperty objects.}
\label{tab:genome-property-object}\\
\hline
\textbf{Name} & \textbf{Type} & \textbf{Description} \\ \hline
\endfirsthead
%
\multicolumn{3}{}%
{{\bfseries Table \thetable\ continued from previous page}} \\
\hline
\textbf{Name} & \textbf{Type} & \textbf{Description} \\ \hline
\endhead
%
required\_steps & Property & Return a list of step objects representing steps that are required to support the existence of the property \\ \hline
child\_genome \_property \_identifiers & Property & Return a list of the genome property identifiers of child genome properties that are used as step evidences for the property \\ \hline
to\_json & Method & Serialize the property to a JSON string \\ \hline
databases & Attribute & A list of database objects representing external database references to the property \\ \hline
references & Attribute & A list of literature reference objects representing external articles discussing the property \\ \hline
private\_notes & Attribute & Private internal notes about the property \\ \hline
tree & Attribute & The genome property tree for to that the property belongs \\ \hline
description & Attribute & A complete description for the property \\ \hline
threshold & Attribute & The minimum number of required steps for to that must be assigned YES in order for the property to be assigned PARTIAL rather than NO support during property assignment \\ \hline
type & Attribute & The type of property (e.g. GUILD, CATEGORY, PATHWAY, etc.) \\ \hline
steps & Attribute & A list of step objects representing all steps that can support the existence of the property (including non-required) \\ \hline
public & Attribute & True if the property is publicly released \\ \hline
children & Attribute & A list of child genome property objects representing properties the are used as step evidences by the property \\ \hline
name & Attribute & The name of the property \\ \hline
id & Attribute & The genome property identifier (e.g. GenPropXXXX) \\ \hline
parents & Attribute & A list of parent genome properties objects representing properties that use the property as step evidences \\ \hline
\end{longtable}

\subsubsection{Example code for using GenomeProperty objects}

\begin{lstlisting}[language=Python]

property.id
Out: 'GenProp0144'
	
property.name
Out: 'Chlorophyllide a biosynthesis from protoporphyrin IX'

property.parents
Out: List of parent property objects

property.children	
Out: List of child property objects

property.steps
Out: List of step objects		
	
property.databases
Out: List of database reference objects

property.references
Out: List of literature reference objects

\end{lstlisting}

\subsection{The DatabaseReference Class}

The DatabaseReference class allows for the creation of objects that link a property to equivalent records in other pathway databases such as KEGG \cite{kanehisa2000kegg} and MetaCyc \cite{karp2002metacyc}. These objects are children of GenomeProperty objects (Fig. \ref{fig:propertytree}). For example, in the case of GenProp0145 (Histidine degradation to glutamate), the GenomeProperty object would have two child DatabaseReference objects. One for the equivalent KEGG pathway (map00340) and another for the equivalent MetaCyc pathway (PWY-5028). DatabaseReference objects can be used to build software that needs to provide links between pathways across multiple databases. A summary of the attributes of DatabaseReference objects can be seen in Table \ref{tab:database-reference-object} and example code below.

\begin{longtable}{|p{2.7cm}|p{2cm}|p{10cm}|}
\caption{The attributes of DatabaseReference objects.}
\label{tab:database-reference-object}\\
\hline
\textbf{Name} & \textbf{Type} & \textbf{Description}                  \\ \hline
\endfirsthead
%
\multicolumn{3}{c}%
{{\bfseries Table \thetable\ continued from previous page}} \\
\hline
\textbf{Name} & \textbf{Type} & \textbf{Description}                  \\ \hline
\endhead
%
database\_name & Attribute  & The name of the database in questions (e.g. KEGG)           \\ \hline
record\_title & Attribute  & The name of the record in the external database for that the property is equivalent  \\ \hline
record\_ids & Attribute  & The identifier of the record in the external database for that the property is equivalent \\ \hline
\end{longtable}

\subsubsection{Example code for using DatabaseReference objects}

\begin{lstlisting}[language=Python]

reference = property.databases[0]
	
reference.database_name
Out: 'MetaCyc'

reference.record_title
Out: 'Pathway: 3,8-divinyl-chlorophyllide a biosynthesis III'

# Returns a list to handle cases where there are multiple identifiers.
reference.record_ids[0] 
Out: 'PWY-7159'

\end{lstlisting}

\subsection{The LiteratureReference Class}

The LiteratureReference class lays out the foundation for objects that represent scientific articles that support the existence of a property, such as a review summarizing current knowledge of a metabolic pathway. Once instantiated, LiteratureReference objects are children of GenomeProperty objects (Fig. \ref{fig:propertytree}). A summary of the attributes of LiteratureReference objects can be seen in Table \ref{tab:literature-reference-object} and example code below.

\begin{longtable}{|p{2.7cm}|p{2cm}|p{10cm}|}
\caption{The attributes of LiteratureReference objects.}
\label{tab:literature-reference-object}\\
\hline
\textbf{Name} & \textbf{Type} & \textbf{Description}     \\ \hline
\endfirsthead
%
\multicolumn{3}{c}%
{{\bfseries Table \thetable\ continued from previous page}} \\
\hline
\textbf{Name} & \textbf{Type} & \textbf{Description}     \\ \hline
\endhead
%
number  & Attribute  & The number of the reference   \\ \hline
pubmed\_id & Attribute  & The PubMed \cite{canese2006pubmed} identifier of the reference \\ \hline
title   & Attribute  & The title of the literature reference for the property    \\ \hline
authors  & Attribute  & The authors of the literature reference for the property   \\ \hline
citation  & Attribute  & A citation for the literature reference for the property   \\ \hline
\end{longtable}

\subsubsection{Example code for using literature reference objects}

\begin{lstlisting}[language=Python]

reference = property.references[0]
	
reference.pubmed_id
Out: '17370354'

reference.title
Out: 'Recent advances in chlorophyll biosynthesis.'

reference.citation
Out: 'Photosynth Res. 2006;90(2):173-194.'

\end{lstlisting}

\subsection{The Step Class}

The Step class is used to generate objects representing individual genome property steps. They are children of parent GenomeProperty objects and have FunctionalElements objects as children (Fig. \ref{fig:property}). A summary of the properties and attributes of Step objects can be seen in Table \ref{tab:step-object} and example code below.

\begin{longtable}{|p{2.7cm}|p{2cm}|p{10cm}|}
\caption{The properties and attributes of Step objects.}
\label{tab:step-object}\\
\hline
\textbf{Name}   & \textbf{Type} & \textbf{Description}                             \\ \hline
\endfirsthead
%
\multicolumn{3}{c}%
{{\bfseries Table \thetable\ continued from previous page}} \\
\hline
\textbf{Name}   & \textbf{Type} & \textbf{Description}                             \\ \hline
\endhead
%
name     & Property  & Return the name of the step                             \\ \hline
required    & Property  & Return true if the step is required for assignment of the parent genome property                \\ \hline
property \_identifiers & Property  & Return a list of genome property identifiers of genome properties that are used as evidence for the step          \\ \hline
interpro \_identifiers & Property  & Return a list of InterPro identifiers \cite{hunter2008interpro} that are used as evidence for the step (e.g. IPRXXXX)             \\ \hline
consortium \_identifiers & Property  & Return a list of InterPro consortium member database (e.g. PFAM \cite{bateman2004pfam}) signature accessions \cite{hunter2008interpro} that are used as evidence for the step (e.g. PFXXXX) \\ \hline
genome \_properties  & Property  & Return a list of child GenomeProperty objects that are used as evidence for the step              \\ \hline
number     & Attribute  & The number of the step                             \\ \hline
parent     & Attribute  & The parent GenomeProperty object of the step                         \\ \hline
functional \_elements & Attribute  & A list of FunctionalElement objects that are used to support the existence a step               \\ \hline
\end{longtable}

\subsubsection{Example code for using step objects}

\begin{lstlisting}[language=Python]

step = property.steps[0]
	
step.number
Out: '1'

step.name
Out: 'Magnesium-chelatase subunit ChlD (EC 6.6.1.1)'

step.required
Out: 'True'

step.interpro_identifiers
Out: 'A list of InterPro identifiers (e.g. IPR011776)'

step.consortium_identifiers 
Out: 'A list of consortium signature identifiers (e.g. TIGR02031)'

step.functional_elements
Out: 'A list of functional element objects'

\end{lstlisting}

\subsection{The FunctionalElement Class}

The FunctionalElement class allows for the instantiation of objects that are placed between Step and Evidence objects during parsing (Fig. \ref{fig:property}). Functional elements are not part of the original Genome Properties database schema and were added by Pygenprop to account for property steps that can be catalyzed by multiple enzyme families. For example, it is common for organisms to use a different set of enzymes to catalyze a step in a biochemical pathway under anoxic conditions, due to the lack of oxygen present to support other reactions. This issue of having multiple types of enzymes capable of catalyzing a step is an open issue on the Genome Properties database Github repository (see \href{github.com/ebi-pf-team/genome-properties/issues/29}{github.com/ebi-pf-team/genome-properties/issues/29}). The addition of FunctionalElements object addresses this issue. A summary of the attributes of FunctionalElement objects can be seen in Table \ref{tab:element-object} and example code below.

\begin{longtable}{|p{2.7cm}|p{2cm}|p{10cm}|}
\caption{The attributes of FunctionalElement objects.}
\label{tab:element-object}\\
\hline
\textbf{Name} & \textbf{Type} & \textbf{Description}                 \\ \hline
\endfirsthead
%
\multicolumn{3}{c}%
{{\bfseries Table \thetable\ continued from previous page}} \\
\hline
\textbf{Name} & \textbf{Type} & \textbf{Description}                 \\ \hline
\endhead
%
parent  & Attribute  & The Step object for to that the FunctionalElement supports       \\ \hline
evidence  & Attribute  & A list of Evidence objects that support the existence of the functional element   \\ \hline
name   & Attribute  & The name of the functional element              \\ \hline
id   & Attribute  & The identifier of the functional element            \\ \hline
required  & Attribute  & True if the functional element is required for assignment of the parent genome property \\ \hline
\end{longtable}

\subsubsection{Example code for using FunctionalElement objects}

\begin{lstlisting}[language=Python]

element = step.functional_elements[0]
	
element.id
Out: 'element.id'

element.name
Out: 'Magnesium-chelatase subunit ChlD (EC 6.6.1.1)'

element.required
Out: 'True'

element.evidence
Out: 'A list of evidence objects'

\end{lstlisting}

\subsection{The Evidence Class}

The Evidence class allows for the generation of objects that represent individual pieces of evidence that support the existence of functional elements and, in turn, genome property steps. Pieces of evidence include the presence of InterPro consortium signatures \cite{hunter2008interpro} or support for the existence of other genome properties found in an organism's genome. A summary of the properties and attributes of Evidence objects can be seen in Table \ref{tab:evidence-object} and example code below.

\begin{longtable}{|p{2.7cm}|p{2cm}|p{10cm}|}
\caption{The properties and attributes of Evidence objects.}
\label{tab:evidence-object}\\
\hline
\textbf{Name}   & \textbf{Type} & \textbf{Description}                                \\ \hline
\endfirsthead
%
\multicolumn{3}{c}%
{{\bfseries Table \thetable\ continued from previous page}} \\
\hline
\textbf{Name}   & \textbf{Type} & \textbf{Description}                                \\ \hline
\endhead
%
has\_genome \_property & Property  & Return true if the evidence is supported by the existence a genome property                    \\ \hline
property \_identfiers & Property  & Return a list of genome property identifiers of genome properties that are used by the evidence               \\ \hline
interpro \_identifiers & Property  & Return a list InterPro identifiers of genome properties that are used by this evidence (e.g. IPRXXXX)              \\ \hline
consortium \_identifiers & Property  & Return a list of InterPro consortium member database (e.g. PFAM) signature identifiers of genome properties that are used by this evidence (e.g. PFXXXXX) \\ \hline
genome \_properties  & Property  & Return a list of child genome property objects that are used by this evidence                    \\ \hline
parent     & Attribute  & The parent functional element of this evidence                          \\ \hline
gene\_ontology \_terms & Attribute  & The Gene Ontology (GO) term identifiers \cite{ashburner2000gene} associated with the InterPro identifiers that are used by the evidence              \\ \hline
evidence \_identifiers & Attribute  & A list of both InterPro and signature identifiers used by the evidence                    \\ \hline
sufficient    & Attribute  & True if the evidence alone can prove the existence of a functional element                   \\ \hline
\end{longtable}

\subsubsection{Example code for using Evidence objects}

\begin{lstlisting}[language=Python]

evidence = element.evidence[0]
	
evidence.has_genome_property
Out: 'false'

evidence.sufficient
Out: 'true'

evidence.interpro_identifiers
Out: 'A list of InterPro identifiers (e.g. IPR011776)'

evidence.consortium_identifiers 
Out: 'A list of consortium signature identifiers (e.g. TIGR02031)'

\end{lstlisting}

\subsection{The GenomePropertiesTree Class} \label{GenomePropertiesTree-Class}

GenomePropertiesTree objects, as instantiated from the GenomePropertiesTree class, are used to represent the rooted directed acyclic graph (DAG) structure of the entire Genome Properties database. \footnote{Even though the Genome Properties database structure is a rooted DAG, the name 'tree' is used in the class name, and tree terminology is used in the object's methods as a means of end-user convenience. Mathematically, a rooted DAG is not a tree because its branches can merge, unlike those of an actual tree. However, they are similar as they both originate from a single root node.} These objects contain a Python dictionary (key-value mapping) of GenomeProperty objects indexed by their property identifiers. Also, individual property objects point to each other using their parent/child attributes (Fig. \ref{fig:propertytree} and Table \ref{tab:genome-property-object}), allowing for climbing up and down the DAG. These parent-child relationships between GenomeProperty objects are built during a GenomePropertiesTree object's instantiation. The GenomePropertiesTree class provides its objects with methods that allow users to search for specific GenomeProperty objects, and acquire lists of the root (i.e., no parent property) and leaf (i.e., no child properties) GenomeProperty objects. A summary of the methods, properties and attributes of GenomePropertiesTree objects can be seen in Table \ref{tab:tree-object} and example code below.

\begin{longtable}{|p{2.7cm}|p{2cm}|p{10cm}|}
\caption{The methods, properties and attributes of GenomePropertiesTree objects.}
\label{tab:tree-object}\\
\hline
\textbf{Name}        & \textbf{Type} & \textbf{Description}                                                               \\ \hline
\endfirsthead
%
\multicolumn{3}{c}%
{{\bfseries Table \thetable\ continued from previous page}} \\
\hline
\textbf{Name}        & \textbf{Type} & \textbf{Description}                                                               \\ \hline
\endhead
%
build\_genome \_property \_connections  & Method  & Iterate through every GenomeProperty that is a child of the tree; set these Properties' parent and child attributes (see \ref{tab:genome-property-object}) to point to matching child and parent GenomeProperty objects fthat are also children of the Tree. This method connects GenomeProperty objects to create a DAG structure. \\ \hline
to\_json         & Method  & Serialize the property tree to a JSON string                                                         \\ \hline
create \_metabolism \_database \_mapping\_file & Method  & Write a Comma-separated values (CSV) file that maps from genome property identifiers to the identifiers of equivalent records found in KEGG and MetaCyc                                     \\ \hline
root          & Property  & Return the top-level GenomeProperty who has no parent.                                                           \\ \hline
leafs          & Property  & Return a list of GenomeProperty objects whose steps are not supported by any other properties                                            \\ \hline
genome \_property \_identifiers    & Property  & Return a list of the genome property identifiers (e.g. GenPropXXXX) for all genome properties within the database                                        \\ \hline
interpro \_identifiers      & Property  & Return a list of InterPro identifiers that are used as evidence for steps (e.g. IPRXXXX) within the database                                        \\ \hline
consortium \_identifiers      & Property  & Return a list of InterPro consortium member database (e.g. PFAM) signature accessions that are used as evidence for steps (e.g. PFXXXXX) within the database                            \\ \hline
consortium \_identifiers \_dataframe   & Property  & Return the above in the form of a pandas DataFrame  \cite{mckinney2010data}                                                        \\ \hline
genome \_properties \_dictionary    & Attribute  & A dictionary of genome property objects representing all genome properties within by the database; the dictionary is keyed by genome property identifier.                              \\ \hline
\end{longtable}

\subsubsection{Example code for using GenomePropertiesTree objects}

\begin{lstlisting}[language=Python]

tree = GenomePropertyTree(*property_object_list)
tree_two = parse_genome_properties_flat_file(properties_file_handle)
	
len(tree) # number of properties in the database
Out: 'false'

tree.root
Out: 'The root FenomeProperty object'

tree.leafs
Out: 'A list of leaf GenomeProperty objects 
     (those with no child properties)'

# Properties in the tree can be iterated.
for genome_property in tree: 
	print(genome_property.id)
Out: 'Prints all genome property identifiers'

# The tree can be rapidly searched
tree['GenProp1127'] 
Out: 'The GenomeProperty object representing GenProp1127.'

\end{lstlisting}

\subsection{Performance of Pygenprop's Genome Properties Database Representation}

Pygenprop's representation of the Genome Properties database as a GenomePropertiesTree object and its children takes only up 11.2 megabytes (MB) of random-access memory (RAM) as of database version 2.0. This memory usage only takes up marginally more space than the database's original \textbf{genomeProperties.txt} file that takes up 1.8 MB on disk. The memory usage difference is due to the representation of the database as a series of objects and their associated data structures. However, since 11.2 MB takes up little main memory (RAM) on a modern machine, a more compact representation for the Genome Properties database was not pursued. The size of the database and its read-only use case allows for its storage in main memory rather than in an on-disk database such as SQLite \cite{owens2006definitive} or PostgreSQL \cite{momjian2001postgresql}.

Individual genome property objects can be looked up, by property identifier, from within a GenomePropertiesTree object within 277 ns \textpm 7.91 ns. This speed is due to property objects being stored within a Python dictionary. Python dictionaries are implemented a hash table, allowing for quick lookups \cite{van1995python}.

\section{Assignment of Genome Properties to Organism Genomes}

Information contained within the Genome Properties database can be used to assign YES, NO or PARTIAL support for an organism possessing a genetically derived property, such as a biochemical pathway. These assignments of YES, NO or PARTIAL support are generated in two ways. One way is from on the presence of InterPro consortium database signatures (e.g., PFAMs, TIGRFAMs and others) in the domain annotations of an organism's proteins. These domain annotations are generated by running InterProScan \cite{jones2014interproscan} on an organism's protein encoded open reading frames (ORFs). The second is from the presence of YES or PARTIAL support for other Genome Properties in the organism's genome (Fig. \ref{fig:propertyassignment}). Pygenprop's code for assigning genome properties is based on that of the Genome Properties Perl library (see \href{github.com/ebi-pf-team/genome-properties}{github.com/ebi-pf-team/genome-propertie}) that ships alongside the Genome Properties database. It replicates the Perl library's support assignment functionality. Pygenprop evaluates properties' support, from DAG leaf to DAG root, using a recursive algorithm (Fig. \ref{fig:propertyassignment}). For each property, assignment starts by assigning each step evidence with YES or NO support and then recursively flowing this assignment up through functional elements, steps and eventually back to the property itself (Fig. \ref{fig:propertyassignment}). This flowing of assignments is done recursively through a series of assignment algorithms for evidence, functional elements, steps and properties (Fig. \ref{fig:propertyassignment}). The rules used for assigning support at different levels is detailed in the subsections below. For each organism that needs to be to have properties assigned, an AssignmentCache object is generated. This object contains all data required for property assignment and methods for assigning support using this data. A detailed description of this class is also found in the subsections below.

\begin{figure}[!ht]
  \centering
	\includegraphics[width=0.90\textwidth]{media/Pygenprop_Assignment.pdf}
	 \caption{An overview of the genome property assignment process used by Pygenprop.}
	 \label{fig:propertyassignment}
\end{figure}

\subsection{The AssignmentCache Class} \label{AssignmentCache}

AssignmentCache objects, instantiated from the AssignmentCache class, are used to assign genome properties to an organism. They can be generated from three sources: 
\begin{itemize}
\item InterProScan Tab-separated values (TSV) files (protein domain annotation files) 
\item Python lists of InterPro member database signature accessions for an organism (as could be downloaded from precalculated InterProScan results of UniProt proteomes \cite{uniprot2014uniprot})
\item Precalculated property assignment files generated by the Genome Properties Perl library
\end{itemize}
Pygenprop contains parsers for both InterProScan TSV files and Genome Properties precalculated property assignment files. In all cases, InterPro member database signature accessions are de-duplicated before their inclusion in an AssignmentCache object, as occurs in the Genome Properties Perl library.

AssignmentCache objects contain two Python dictionaries (i.e., key-value mappings) for storing previously calculated property and step assignments, respectively. It also contains a Python set that is designed to store all unique InterPro consortium signature identifiers found in an organism's protein domain annotations. The AssignmentCache has a method called \textbf{bootstrap\_assignments} that uses a GenomePropertyTree (Subsection \ref{GenomePropertiesTree-Class}) object and data stored within itself to calculate levels of support for all properties. This function also calculates levels of support for steps. AssignmentCaches from multiple organisms can later be combined during the creation of GenomePropertiesResults objects (as discussed in Section \ref{GenomePropertiesResults} below), thus allowing comparison of properties between organisms. As mentioned above these caches can be from different sources. Unlike Pygenprop, the Genome Properties Perl library does not maintain the concept of an assignment cache and can only calculate property support for a single organism from a single InterProScanTSV file. A summary of the methods, properties and attributes of AssignmentCache objects can be seen in Table \ref{tab:assignment-cache-object} and example code below.

\begin{longtable}{|p{2.7cm}|p{2cm}|p{10cm}|}
\caption{The methods, properties and attributes of AssignmentCache objects.}
\label{tab:assignment-cache-object}\\
\hline
\textbf{Name} & \textbf{Type} & \textbf{Description} \\ \hline
\endfirsthead
%
\multicolumn{3}{c}%
{{\bfseries Table \thetable\ continued from previous page}} \\
\hline
\textbf{Name} & \textbf{Type} & \textbf{Description} \\ \hline
\endhead
%
cache\_property \_assignment & Method & Add a property assignment to the cache \\ \hline
get\_property \_assignment & Method & Return a property assignment from the cache \\ \hline
cache\_step \_assignment & Method & Add a step assignment to the cache \\ \hline
get\_step \_assignment & Method & Retrun a step assignment from the cache \\ \hline
flush\_property \_from\_cache & Method & Remove a property assignment and its associated step assignments from the cache \\ \hline
synchronize \_with\_tree & Method & If a property whose assignment is cached is not found in the tree, remove its assignment and associated step assignments. This method allows for compatibility between different versions of the Genome Properties database and pre-calculated assignment files. \\ \hline
bootstrap \_assignments & Method & Recursively assign support for properties from leaf to root using an internal set pre-calculated assignments and a InterPro consortium signature identifiers. \\ \hline
bootstrap \_missing\_step \_assignments & Method & Search through a genome property tree to find steps that are not in the cache. Assign these steps NO since they are missing. This method is used when pre-calculated step assignments that result in NO have been omitted to save disk space. \\ \hline
create \_results\_tables & Method & Return two pandas DataFrames representing property and step assignments for the organism \\ \hline
property \_identifiers & Property & Return a list of genome property identifiers (e.g. GenPropXXXX) for properties whose assignment are in the cache \\ \hline
property \_assignments & Attribute & A Python dictionary of YES, NO and PARTIAL labelled property assignments keyed by genome property identifier. \\ \hline
step \_assignments & Attribute & A doubly nested Python dictionary of YES, and NO labelled step assignments keyed by genome property identifier and step number. \\ \hline
interpro \_signiture \_accessions & Attribute & A set of InterPro consortium signature identifiers of domains found in the organism's protein domain annotations. \\ \hline
sample\_name & Attribute & The name of the organism or sample. When the AssignmentCache is created from a file, the sample name is set to the filename without file extension. \\ \hline
\end{longtable}

\subsubsection{Example code for using AssignmentCache  objects}

\begin{lstlisting}[language=Python]
tree = parse_genome_properties_flat_file(properties_file_handle)

cache1 = parse_genome_property_longform_file(pre_calculated_file_handle)
cache2 = parse_interproscan_file(interproscan_tsv_file_handle)
cache3 = AssignmentCache(sample_name='E_coli', 
interpro_signature_accessions=identifier_list)

cache2.sample_name
Out: 'C_benthia_SPR155'

cache2.get_property_assignment('GenProp1065')
Out: 'PARTIAL'

cache2.get_step_assignment('GenProp1067', 2) 
Out: 'YES'

# Set GenProp2536 to YES
cache2.cache_property_assignment('GenProp2536', 'YES')

# Set GenProp2539 step two to YES
cache2.cache_step_assignment('GenProp2539', 2, 'YES')

# Remove GenProp2567 from the cache
cache2.flush_property_from_cache('GenProp2567')

# Bootstrap both step and property assignments
cache2.boostrap_assignments(properties_tree=tree)

# Create pandas DataFrames for per organism property
# and step assignments
tables = cache2.create_results_tables(properties_tree=tree)
property_table = tables[0]
step_table = tables[1]

\end{lstlisting}

\subsection{Implemented Assignment Algorithms} \label{AssignmentCachingAlgorithm}

As mentioned above, Pygenprop uses recursion, the process of program functions repeatedly calling themselves internally, to assign YES, NO or PARTIAL support for individual properties found within the Genome Properties database. During assignment recursion, Pygenprop uses a GenomePropertiesTree object (Subsection \ref{GenomePropertiesTree-Class}) to provide itself with information about assignment requirements for each property and relevant connections between properties. In the context of AssignmentCache objects, the process of generating of assignments of support is referred to as bootstrapping. This process is designated as bootstrapping because properties are assigned from a mixture of existing pieces of information stored within the cache such as pre-calculated property and step assignments, and InterPro consortium signature accessions. Pygenprop's recursive assignment algorithms, like those in the Genome Properties Perl library, assign support to both properties and property steps (Fig. \ref{fig:propertyassignment}). Assignments of support for steps are used to assign support for parent properties (Fig. \ref{fig:propertyassignment}).

During the recursion process, the newly calculated step and property assignments are added continually to the AssignmentCache object's step and property assignment dictionaries (Table \ref{tab:assignment-cache-object}). During successive recursive assignment calculations, these dictionaries are checked first, using the AssignmentCache's \textbf{get\_property\_assignment} and \textbf{get\_step\_assignment} methods (Table \ref{tab:assignment-cache-object}), to find step and property assignments that have already been calculated in previous recursive cycles. Because the Genome Properties database forms a rooted DAG, branches in the parent-child property relationships can merge and thus over time, there will be additional assignments to retrieve from the AssignmentCache dictionaries. The result of using these previously cached assignments is that the assignment process will increase exponentially in speed as more properties are calculated, vastly reducing assignment time (as discussed in Subsection \ref{AssignmentCache-Performance} below). Also, the AssignmentCache's step and property dictionaries can contain pre-calculated assignments from an assignment file or database. Assignments that are already cached are taken as gospel, and programmatic recursion stops when they are collected from their dictionaries. Recursion also stops when step assignments are calculated for steps that are not supported by child genome properties \ref{fig:propertyassignment}).

\subsubsection{Assigning support for steps, functional elements and evidences}

Step assignments are calculated recursively from both functional element and evidence assignments (Fig. \ref{fig:propertyassignment}). Evidences are assigned YES or NO based on the presence an InterPro consortium signatures found in an AssignmentCache's \textbf{interpro \_signiture \_accessions} attribute (Table \ref{tab:assignment-cache-object}) or a recursively calculated property assignment (Fig. \ref{fig:propertyassignment}). The signature identifier or child property to be used during calculations is specified inside each evidence's representative Evidence object (Table \ref{tab:evidence-object}). This Evidence object is a child of a GenomeProperty object and this GenomeProperty is found inside the GenomePropertyTree object passed to the AssignmentCache's \textbf{bootstrap\_assignments} function. Pieces of evidence are assigned NO in two situations: 
\begin{itemize}
\item The evidence's InterPro consortium signature is not found in the AssignmentCache's \textbf{interpro \_signiture \_accessions} attribute 
\item The evidence's child genome property has been assigned NO 
\end{itemize}
Otherwise, each evidence is assigned YES (Fig. \ref{fig:propertyassignment}). Functional elements are assigned YES under two situations: 
\begin{itemize}
\item If all underlying pieces of evidence have been assigned YES
\item If a single piece of evidence that sufficient on its own to support the existence of a step is assigned YES. \footnote{As mentioned in Table \ref{tab:evidence-object}, some pieces of evidence can be used as the sole piece of evidence for a step (Fig. \ref{fig:propertyassignment}).}
\end{itemize}
Other than these two situations, the functional element is assigned NO (Fig. \ref{fig:propertyassignment}). Steps are assigned YES or NO based on the assignments of functional elements (Fig. \ref{fig:propertyassignment}). Steps are assigned YES only if all functional elements of that step have been assigned YES and are assigned NO otherwise. As noted in the above section, assignment results for already calculated steps are checked for before step assignment recursion and are added to the AssignmentCache after step assignment calculations. If a piece of evidence has a genome property as its child, then this property's assignment is calculated, creating another recursion cascade.

\subsubsection{Assigning support for non-categorical properties}

Some properties have steps that are required to exist for the property to be assigned YES or PARTIAL. Also, each property is given a \textbf{threshold} attribute (Table \ref{tab:genome-property-object}), that specifies how many of these required steps must be present before an assignment of PARTIAL support can be applied to the property. If there are required steps for a property, as specified by the information contained in a GenomeProperty object of a GenomePropertyTree, then the genome property can only be assigned YES if all required steps are present (Fig. \ref{fig:propertyassignment}). The property is assigned PARTIAL only if the number of its required steps assigned YES is greater than the amount found in its required steps threshold attribute (Fig. \ref{fig:propertyassignment}). If the number of required steps assigned YES is less than or equal to the required steps threshold, then the property is assigned NO support. It is important to note that property assignment does not take into account steps that are optional, only those that are required. As pointed out in the above Subsection \ref{AssignmentCachingAlgorithm}, assignments for already calculated properties are checked for before property assignment recursion and are added to the AssignmentCache after property assignment calculations. If a property's step's assignment value is not known, it is calculated causing a recursion cascade.

\subsubsection{Assigning support for categorical properties}

Categorical properties, such as GenProp0065 (metabolism), do not have any required steps; all steps are optional. Thus a different assignment algorithm is required for these propertys assignments. Categorical properties are only assigned YES if all steps are assigned YES, NO if all steps are assigned NO and PARTIAL otherwise (Fig. \ref{fig:propertyassignment}). Note that the generation of support assignments for categorical properties is unique to Pygenprop and is not performed by the Genome Properties Perl library. The recursion in the Perl library stops before it reaches categorical properties.

\subsection{AssignmentCache and Assignment Algorithm Performance} \label{AssignmentCache-Performance}

For a 2.93 MB InterProScan TSV file containing domain annotations for 4100 \textit{Escherichia coli} K12 proteins, the resulting AssignmentCache object was found to take up 1.16 MB of main memory before bootstrapping assignments and 1.71 MB after. Assignment bootstrapping was found to take 76.7 \textpm 15.41 ms for K12. Thus, Pygenprop could calculate property assignments for thousands of genomes in only a few minutes. This speed was found to be sufficient. However, further performance gains could be made in the future if assignments were stored inside pandas DataFrames \cite{mckinney2010data} similar to those created by an AssignmentCache object's \textbf{create\_results\_tables} method (Table \ref{tab:assignment-cache-object}), rather than a simple Python dictionary.

\section{Development of a Framework for Comparing Genome Property Assignments Across Multiple Organisms} \label{GenomePropertiesResults}

One of the main goals of Pygenprop was to facilitate comparisons of the presence/absence of biochemical pathways across multiple organisms. It allows researchers to perform these comparisons programmatically. Specifically, it provides methods to filter out genome properties that are shared between organisms, thus highlight differences in these organisms' metabolic or functional capabilities. Pygenprop's ability to assess these differences programmatically will allow future researchers to automate many aspects of pathway analysis, such as complex phenotype prediction and the discovery of correlations between pathway presence and patterns of niche partitioning \cite{finke2008niche}. To support programmatic exploration of genome properties assignments, Pygenprop includes the GenomePropertiesResults class. 

\subsection{The GenomePropertiesResults Class}

Objects of the GenomePropertiesResults class take a series of AssignmentCache objects (Subsection \ref{AssignmentCache}), potentially from disparate sources, as input during their instantiation (Fig. \ref{fig:resultscreation}). During this process, the per-sample assignments found within these input caches are transformed into a multiple sample form. Specifically, they are stored as two indexed pandas DataFrames \cite{mckinney2010data}, one for property assignments and another for step assignments (Fig. \ref{fig:resultswithmatchescreation}). The GenomePropertiesResults class also contains a series of methods that return versions of these DataFrames with filtered down step and property assignments. A summary of the methods, properties and attributes of GenomePropertiesResults objects can be seen in Table \ref{tab:results-object} and example code below. GenomePropertiesResults objects become quite useful when used interactively in Jupyter Notebooks \cite{kluyver2016jupyter}. See \href{github.com/Micromeda/pygenprop/blob/master/docs/source/\_static/tutorial/tutorial.ipynb}{github.com/Micromeda/pygenprop/blob/master/docs/source/\_static/tutorial/tutorial.ipynb} for an example notebook workflow using Pygenprop to compare virulence genome properties of \textit{E. coli} K12 and O157:H7.

\begin{figure}[!ht]
  \centering
	\includegraphics[width=0.85\textwidth]{media/assignment_results_overview.pdf}
	 \caption{GenomePropertiesResults objects are created by combining the AssignmentCache objects generate for multiple organisms. These caches can be generated from disparate sources, such as InterProScan results files or lists of InterPro signatures provided by an remote server.}
	 \label{fig:resultscreation}
\end{figure}

\begin{longtable}{|p{2.7cm}|p{2cm}|p{10cm}|}
\caption{The methods, properties and attributes of GenomePropertiesResults objects.}
\label{tab:results-object}\\
\hline
\textbf{Name} & \textbf{Type} & \textbf{Description} \\ \hline
\endfirsthead
%
\endhead
%
get\_results & Method & Return the assignment results as a pandas DataFrame for a series of genome properties at either a step or property level \\ \hline
get\_results \_summary & Method & Return a summary of assignment results as a pandas DataFrame for a series of genome properties at either a step or property level \\ \hline
get\_property \_results & Method & Return a list of assignments of support for all samples and for a given property \\ \hline
get\_step\_results & Method & Return a list of assignments for all samples and for a given property step \\ \hline
to\_json & Method & Serialize the results object to a JSON property tree with assignment results for each sample annotating each property node \\ \hline
to\_assignment \_database & Method & Serialize the results object to a Micromeda SQLite database file (.micro) \\ \hline
to\_msgpack & Method & Serialize the results object to a MessagePack binary string \\ \hline
sample\_names & Property & Return the names of all organisms used in the creation of the results object. \\ \hline
differing \_property \_results & Property & Return a pandas DataFrame of property assignments with properties whose assignments are the same across all samples filtered out \\ \hline
differing\_step \_results & Property & Return a pandas DataFrame of step assignments with steps whose assignments are the same across all samples filtered out \\ \hline
supported \_property \_results & Property & Return a pandas DataFrame of property assignments with properties whose assignments are NO across all samples filtered out \\ \hline
supported\_step \_results & Property & Return a pandas DataFrame of step assignments with steps whose assignments are NO across all samples filtered out \\ \hline
property\_results & Attribute & A pandas DataFrame of property assignments across all samples \\ \hline
step\_results & Attribute & A pandas DataFrame of step assignments across all samples \\ \hline
tree & Attribute & The GenomePropertiesTree object provided during instantiation of the GenomePropertiesResults object \\ \hline
\end{longtable}

\subsubsection{Example code for using GenomePropertiesResults objects}

\begin{lstlisting}[language=Python]
tree = parse_genome_properties_flat_file(properties_file_handle)

cache_one = parse_interproscan_file(ipr_file_handle_one)
cache_two = parse_interproscan_file(ipr_file_handle_two)
results = GenomePropertiesResults(cache_one, cache_two, 
                                  properties_tree=property_tree)

results.sample_names
Out: ['E_coli_K12', 'C_luteolum_DSM_273']

results.get_property_result('GenProp1065')
Out: ['NO', 'NO']

results.get_step_result('GenProp1067', 2) 
Out: ['YES', 'NO']

# Get step assignments for GenProp1065 and GenProp1067 with 
# property and step names.
results.get_results('GenProp1065', 'GenProp1067', 
                      steps=True, names=True)
Out:
\end{lstlisting}

\begin{table}[!ht]
\centering
\resizebox{\textwidth}{!}{%
\begin{tabular}{|l|l|l|l|l|l|}
\hline
\textbf{Property\_Identifier} & \textbf{Property\_Name} & \textbf{Step\_Number} & \textbf{Step\_Name} & \textbf{E\_coli\_K12} & \textbf{C\_luteolum\_DSM\_273} \\ \hline
GenProp1065 & Radical SAM/SPASM TIGR04347/TIGR04031 system & 1 & RSAM-partnered protein, Htur\_1727 family & NO & NO \\ \hline
GenProp1065 & Radical SAM/SPASM TIGR04347/TIGR04031 system & 2 & Pseudo-rSAM protein/SPASM domain protein & NO & NO \\ \hline
GenProp1067 & Defense systems & 1 & CRISPR systems & YES & YES \\ \hline
GenProp1067 & Defense systems & 2 & Restriction enzyme system, type I & YES & NO \\ \hline
GenProp1067 & Defense systems & 3 & DNA sulfur modification system dnd & NO & NO \\ \hline
GenProp1067 & Defense systems & 4 & Abortive infection proteins & NO & NO \\ \hline
GenProp1067 & Defense systems & 5 & Complement activation, common pathway 1 & NO & NO \\ \hline
\end{tabular}%
}
\end{table}

\begin{lstlisting}[language=Python]
# Get property assignments for GenProp1065 and GenProp1067
results.get_results('GenProp1065', 'GenProp1067', 
                    steps=False, names=False)
Out:
\end{lstlisting}

\begin{table}[!ht]
\centering
\begin{tabular}{|l|l|l|}
\hline
\textbf{Property\_Identifier} & \textbf{E\_coli\_K12} & \textbf{C\_luteolum\_DSM\_273} \\ \hline
GenProp1065 & NO & NO \\ \hline
GenProp1067 & PARTIAL & PARTIAL \\ \hline
\end{tabular}
\end{table}

\begin{lstlisting}[language=Python]
# Get counts of YES and NO assignments for steps GenProp1065 
# and GenProp1067
results.get_results_summary('GenProp1065', 'GenProp1067', steps=True)
Out:
\end{lstlisting}

\begin{table}[!ht]
\centering
\begin{tabular}{|l|l|l|}
\hline
\textbf{Assignment} & \textbf{E\_coli\_K12} & \textbf{C\_luteolum\_DSM\_273} \\ \hline
NO & 5 & 6 \\ \hline
YES & 2 & 1 \\ \hline
\end{tabular}
\end{table}

\begin{lstlisting}[language=Python]
# Get percentages of YES and NO assignments for steps GenProp1065 
# and GenProp1067
results.get_results_summary('GenProp1065', 'GenProp1067', 
                             steps=True, normalize=True)
Out:
\end{lstlisting}

\begin{table}[!ht]
\centering
\begin{tabular}{|l|l|l|}
\hline
\textbf{Assignment} & \textbf{E\_coli\_K12} & \textbf{C\_luteolum\_DSM\_273} \\ \hline
NO & 71.428571 & 85.714286 \\ \hline
YES & 28.571429 & 14.285714 \\ \hline
\end{tabular}
\end{table}

\subsection{The use of Pandas for Compatibility With the Python Data Science and Machine Learning Software Stack}

Pandas is a Python library for cleaning, filtering and reshaping data. It presents data to users as a DataFrame, which is a two-dimensional data matrix with both column and row names. Pandas DataFrames allow users to index columns, supporting the rapid joining of datasets. These DataFrames were designed to provide Python with similar functionality to the builtin data frames presented by other data analysis languages such as R \cite{rprogman}. Pandas DataFrame objects are built on top of NumPy arrays \cite{mckinney2010data}, which are low-memory data structures designed to support vectorized mathematical calculations on both numeric and string data \cite{van2011numpy}. They are roughly equivalent to R vectors \cite{rprogman}. NumPy arrays are used extensively across the entire Python data science stack, called SciPy \cite{scipystack}, and allow for the transfer of data between algorithms provided by libraries within the stack.

Pygenprop's GenomePropertiesResults object presents property and step assignments as pandas DataFrames. These DataFrames allow users to quickly query and filter assignments using pandas idioms and join assignments to pre-existing metadata. For example, gene expression data (microarray or transcriptomic), culture optimal growth conditions or even host environmental conditions could be merged with genome property assignment results in only a few lines of pandas code. Once these datasets are joined, they can be co-visualized using libraries such as Bokeh \cite{bokeh} and Seaborn \cite{seaborn}. Bokeh can even be used to generate data visualization dashboards, which are small websites that present pre-built charts that other researchers can use \cite{bokeh}. These dashboards are equivalent to R's Shiny apps \cite{beeley2013web}. These joined datasets provide great potential as a source of data for data mining or as training sets for machine learning algorithms. Specifically, the NumPy arrays inside pandas DataFrames can easily be transferred to machine learning libraries in the SciPy ecosystem, such as Scikit-learn \cite{pedregosa2011scikit}, PyTorch \cite{Paszke2017} or Tensorflow \cite{abadi2016tensorflow}. Scikit-learn can be used to cluster the above joint data to mine for patterns of interest as well as to build machine learning classifiers. These classifiers can be used to make predictions of an organism's capabilities based on its genome property assignments. Examples of classifiers provided by Scikit-learn include Support Vector Machine (SVM) and Random Forests \cite{pedregosa2011scikit}.

\subsection{GenomePropertiesResults Performance}

When generated from two AssignmentCache objects containing assignments for two bacteria with 4100 and 1877 proteins, respectively, the resulting GenomePropertiesResults object took up 14.4 MB of main memory after instantiation. Creating the object took 177 ms \textpm 10 ms. Thus, Pygenprop could create a GenomePropertiesResults object from thousands of assignment caches in only a few tens of minutes and only a few gigabytes of RAM. This speed was found to be sufficient. It appears that as after an initial empty size of approximately 10 MB, as more organisms are added to the GenomePropertiesResults object, it only grows by only a few MB per new organism rather than tens of MB. This first 10 MB is likely due to the cost of setting up the object's pandas DataFrames. If one needed lower memory usage, they could store assignments as raw unindexed NumPy arrays inside GenomePropertiesResults objects rather than pandas DataFrames. 

\section{Extension of the AssignmentCache and GenomePropertiesResults classes to Include Supporting Match Information}

Motifs are discrete patterns in a protein's sequence, that are often associated with the existence of a protein domain. A protein domain is conserved part of a protein's sequence that carries out a specific function for the protein and is evolutionarily conserved. These domains often generate discrete three-dimensional structures during folding of their parent protein. Domain annotation is the process of predicting the placement and function of domains in protein sequences. During the genomic analysis, it is common practice to perform domain annotation on an organism's predicted proteins.

Domain annotations of an organism's proteins are created by finding similarities between motifs in an organism's proteins and previously seen motifs of domains from other proteins found in a protein database. If an organism and database motif are highly similar in protein sequence, they are said to form a match. The quality of this match can be quantified by metrics such as expected value (E-value) score. A match's E-value score captures how likely it is that the match is real given the chance of finding an equivalent match randomly in one of the organism's other proteins. If we determine that a match is of high quality, the motif in the organism's protein can be assigned the same name and function as the original domain motif the protein database.

One tool for performing domain annotation of an organism's proteins is InterProScan, which predicts both the type and placement of domains in an organism's proteins and also provides supporting match information to justify its predictions. This supporting information includes E-value scores for matches and predicted domain start and stop points on the annotated protein. InterProScan takes a FASTA file \cite{pearson19905} containing an organism's predicted proteins as input and writes domain annotations and match data to tab-separated value (TSV) files.

As mentioned in previous sections, Genome properties are assigned based on the presence of InterPro domains that can be used, either singly or in combination, to uniquely identify enzymes or protein structures that act as evidence for property steps. It may be the case that domains used as step evidences will be found in more than one protein of an organism. It may also be the case that some of these proteins may be false positives that may posses the identifying domain, or a similar domain, but do not carry out a genome property step. To filter out these false positives, researchers often want direct access to match information, such as E-value scores, held within an InterProScan file, so they can use it to filter matches further. Alternatively, users may want access to the entire sequence of proteins containing predicted domains so they can be analyzed more deeply. For example, the proteins that are predicted to possess a motif that supports the existence of a property step could be compared phylogenetically to reference proteins that are already known carry out this step in other organisms. Proteins that cluster tightly together on phylogenetic trees are more likely to possess the same function than proteins found to be an outgroup.

Previously, with the Genome Properties Perl library, the information required to perform the above analyses were kept in four separate file types: 
\begin{itemize}
\item GenomeProperties.txt files kept property information
\item Per-organism long-form property assignment files kept property and step assignments
\item Per-organism FASTA files \cite{pearson19905} kept protein sequences 
\item  Per-organism InterProScan TSV files kept domain annotations 
\end{itemize}
For a given organism, if one wanted to find proteins that support the existence of a genome property step they would have to write a script to parse all four of these file types, combine the data contained within each and perform searches on this data. These scripts would be difficult and time-consuming to write as they would need much "boilerplate" code to carry out the joining of the datasets before analysis. Since the above file types are created per-organism, if one wanted to apply such scripts to multiple organisms, then these scripts would have to be able to remember that file belongs to what organism. This tracking would further complicate script development.

Pygenprop already possesses much much of the aforementioned boilerplate code. For example, code for parsing the Genome Properties database and for comparing the presence/absence of genome properties across organisms. To make it easier for researchers to access domain and sequence information for proteins that support the existence of genome property steps, Pygenprop contains extended versions of both the AssignmentCache and GenomePropertiesResults classes. These classes possess attributes, properties and methods related to accessing the supporting information that was initially provided only within InterProScan TSV and FASTA files. These classes are called AssignmentCacheWithMatches and GenomePropertiesResultsWithMatches, respectively.

\subsection{Considerations for the Retention of Match Information in AssignmentCacheWithMatches and GenomePropertiesResultsWithMatches objects} \label{MatchConsiderations}

GenomePropertiesResultsWithMatches objects can generate pathway annotation files, called Micromeda files (see Section \ref{MicromedaFiles}), that store both property and step assignments and the information supporting their existence. Examples of such supporting information include InterPro domain annotations and protein sequences of an organism. A single Micromeda file can store the property assignments and supporting information for multiple genomes. GenomePropertiesResultsWithMatches objects are intended to be serializable to and from Micromeda files. Thus both GenomePropertiesResultsWithMatches objects and Micromeda files must store the same information.

One of the space-saving optimizations used in the creation of Micromeda files, and thus GenomePropertiesResultsWithMatches objects, is to retain only the supporting information for property steps that are assigned YES, rather than an entire dataset of domain annotations and protein sequences. During the process of generating GenomePropertiesResultsWithMatches objects, Pygenprop drops supporting information that is not used to assign steps YES.

Note that only retaining supporting information for steps that are assigned YES generates a corner case. This corner case can found when a property step is assigned NO support, but one or more of its pieces of evidence are still assigned YES (Fig. \ref{fig:propertyassignment}). In this case, the match information supporting this evidence is dropped from Micromeda files and GenomePropertiesResultsWithMatches objects since the parent step has been assigned NO. The choice to not retain supporting information for all evidence regardless of their parent step's assignment status was made to reduce the complexity and memory requirements of Micromeda files. It was made based on the assumption that researchers would rarely look at match information for property steps assigned NO.

\subsection{The AssignmentCacheWithMatches Class}

The AssignmentCacheWithMatches class extends the AssignmentCache class via class inheritance \cite{snyder1986encapsulation} (see \href{en.wikipedia.org/wiki/Inheritance\_(object-oriented\_programming)}{en.wikipedia.org/wiki/Inheritance\_(object-oriented\_programming)}). In addition to the attributes, properties and methods inherited from the AssignmentCache class, the AssignmentCacheWithMatches also possesses equivalents used accessing supporting information. This supporting information includes domain annotation E-value scores and protein sequences that support the existence of property steps. This information is stored in a pandas DataFrame within each instantiated AssignmentCacheWithMatches object. 

AssignmentCacheWithMatches objects are generated by parsing a FASTA file \cite{pearson19905} of an organism's proteins and an associated InterProScan TSV of the domain annotations of these proteins (Fig. \ref{fig:cachewithmatchescreation}). Parsing begins with pandas parsing the TSV file into a DataFrame consisting of the file's protein sequence identifier, InterPro consortium signature accession and E-value score columns (Fig. \ref{fig:cachewithmatchescreation}). Each row corresponds to a protein domain annotation. The FASTA file is then parsed using Scikit-bio's FASTA file parser (Fig. \ref{fig:cachewithmatchescreation})\cite{scikitbio}. \footnote{Scikit-bio is a Python bioinformatics library that uses NumPy arrays to store sequence data. The use of NumPy arrays allows for it to have superior performance, in terms of memory usage and sequence string manipulation, to competing for bioinformatics libraries such a Biopython \cite{cock2009biopython}.} Once parsed by Scikit-bio, the FASTA sequences are converted to a pandas DataFrame consisting of two columns, one for protein identifiers and another for protein sequences (Fig. \ref{fig:cachewithmatchescreation}). This sequence DataFrame is then merged with the above domain annotation DataFrame on via their protein identifier columns, creating a third unified DataFrame that is added to an instantiating AssignmentCacheWithMatches object (Fig. \ref{fig:cachewithmatchescreation}). This object contains all matches and proteins sequences found in a FASTA file and associated InterProScan file. A summary of the attributes of AssignmentCacheWithMatches objects can be seen in Table \ref{tab:assignmentcachewithmatches}.

\begin{figure}[!ht]
  \centering
	\includegraphics[width=0.80\textwidth]{media/assignmentcachewithmatches_creation.pdf}
	 \caption{AssignmentCacheWithMatches objects are generated from a FASTA file of an organism's proteins and and InterProScan TSV file of domain annotations of these proteins.}
	 \label{fig:cachewithmatchescreation}
\end{figure}

\begin{longtable}{|p{2.7cm}|p{2cm}|p{10cm}|}
\caption{The attributes of AssignmentCacheWithMatches objects that are not possessed by AssignmentCache objects.}
\label{tab:assignmentcachewithmatches}\\
\hline
\textbf{Name} & \textbf{Type} & \textbf{Description}                                                                                    \\ \hline
\endfirsthead
%
\multicolumn{3}{c}%
{{\bfseries Table \thetable\ continued from previous page}} \\
\hline
\textbf{Name} & \textbf{Type} & \textbf{Description}                                                                                    \\ \hline
\endhead
%
matches       & Attribute     & A pandas DataFrame containing domain annotation information and protein sequences for an organism \\ \hline
\end{longtable}

\subsection{The GenomePropertiesResultsWithMatches Class} \label{PropertyResultsWithMatches}

The GenomePropertiesResultsWithMatches class extends the GenomePropertiesResults class via class inheritance \cite{snyder1986encapsulation}. In addition to the attributes, properties and methods inherited from the GenomePropertiesResults class, it also possesses equivalents used for accessing supporting information. This supporting information includes domain annotation E-value scores and protein sequences that support the existence of property steps. A pandas DataFrame within each instantiated GenomePropertiesResultsWithMatches object stores this information. Unlike AssignmentCacheWithMatches objects, GenomePropertiesResultsWithMatches objects maintain supporting data for more than one organism.

GenomePropertiesResultsWithMatches objects are generated by combining a series of AssignmentCacheWithMatches objects for different organisms (Fig. \ref{fig:resultswithmatchescreation}). During instantiation, the \textbf{matches} DataFrame (Table \ref{tab:assignmentcachewithmatches}) of multiple input AssignmentCacheWithMatches objects are combined into a single more massive DataFrame. Sample names, genome property identifier and step number columns are then used to index this DataFrame, allowing for fast lookups. Having a large combined DataFrame allows for E-value scores and sequences to be compared across organisms. During the creation of this DataFrame, domain annotations and proteins that do not support genome property steps are filtered out. The GenomePropertiesResultsWithMatches class provides a variety of convenience functions for accessing domain annotations for proteins that assist in the assignment of a property step. These functions are capable of providing filtered DataFrames that compare matches across organisms. It can be also be used to generate FASTA files, using Scikit-bio, containing proteins that are predicted to carry out property a step in numerous organisms. A summary of the methods, properties and attributes of GenomePropertiesResultsWithMatches objects can be seen in Table \ref{tab:genomepropertyresultswithmatches} and example code below. 

\begin{figure}[!ht]
  \centering
	\includegraphics[width=0.65\textwidth]{media/assignment_results_with_matches_overview.pdf}
	 \caption{GenomePropertiesResultsWithMatches objects are created by combining the AssignmentCacheWithMatches objects generated for multiple organisms. These caches are generated from per-organism FASTA files and InterProScan TSV files. Property and step assignment DataFrames from Fig. \ref{fig:resultscreation} are also retained (not shown).}
	 \label{fig:resultswithmatchescreation}
\end{figure} 

\begin{longtable}{|p{2.7cm}|p{2cm}|p{10cm}|}
\caption{The methods, properties and attributes of GenomePropertiesResultsWithMatches objects not possessed by GenomePropertiesResults objects.}
\label{tab:genomepropertyresultswithmatches}\\
\hline
\textbf{Name} & \textbf{Type} & \textbf{Description} \\ \hline
\endfirsthead
%
\multicolumn{3}{c}%
{{\bfseries Table \thetable\ continued from previous page}} \\
\hline
\textbf{Name} & \textbf{Type} & \textbf{Description} \\ \hline
\endhead
%
get\_sample \_matches & Method & Return the step matches DataFrame filtered to include matches from only one sample \\ \hline
get\_property \_matches & Method & Return the step matches DataFrame filtered to include matches from only one genome property \\ \hline
get\_step \_matches & Method & Return the step matches DataFrame filtered to include matches from only one genome property step \\ \hline
get\_supporting \_proteins\_for \_step & Method & Return a list of Scikit-bio sequences objects for proteins that have domain annotations that support a specific property step to a FASTA file \\ \hline
write \_supporting \_proteins\_for \_step\_fasta & Method & Write the protein sequences that have domain annotations that support a specific property step to a FASTA file \\ \hline
top\_step \_matches & Property & Return the matches DataFrame with only the matches with the lowest E-value for each sample and property step retained \\ \hline
step\_matches & Attribute & A pandas DataFrame containing both domain annotations and sequences for proteins that support genome property steps in multiple samples \\ \hline
\end{longtable}

\subsubsection{Example code for using GenomePropertiesResults objects}

\begin{lstlisting}[language=Python]
tree = parse_genome_properties_flat_file(properties_file_handle)

cache_one = parse_interproscan_file_and_fasta_file(ipr_file_one,
                                                   fasta_file_one)
cache_two = parse_interproscan_file_and_fasta_file(ipr_file_two,
                                                   fasta_file_two)
results = GenomePropertiesResultsWithMatches(cache_one, cache_two,          
                                      properties_tree=property_tree)
\end{lstlisting} 

\pagebreak

\begin{lstlisting}[language=Python]        
results.get_step_matches('GenProp1764', 1)
Out:
\end{lstlisting}

\begin{table}[!ht]
\centering
\resizebox{\textwidth}{!}{%
\begin{tabular}{|l|l|l|l|l|}
\hline
\textbf{Sample\_Name} & \textbf{Signature\_Accession} & \textbf{Protein\_Accession} & \textbf{E-value} & \textbf{Sequence} \\ \hline
C\_chlorochromatii\_CaD3 & PF00994 & NC\_007514.1\_1113 & 7.1e-19 & MITV... \\ \hline
C\_chlorochromatii\_CaD3 & PF00994 & NC\_007514.1\_151 & 1.3e-31 & MRAV… \\ \hline
C\_chlorochromatii\_CaD3 & PF00994 & NC\_007514.1\_1114 & 1.6e-29 & MTFT... \\ \hline
C\_luteolum\_DSM\_273 & PF00994 & NC\_007512.1\_2044 & 2.2e-29 & MPSI... \\ \hline
C\_luteolum\_DSM\_273 & PF00994 & NC\_007512.1\_147 & 1.3e-28 & MAFT... \\ \hline
C\_luteolum\_DSM\_273 & PF00994 & NC\_007512.1\_148 & 3.7e-26 & MLTS... \\ \hline
C\_luteolum\_DSM\_273 & PF01507 & NC\_007512.1\_1607 & 6.1e-38 & MSSA... \\ \hline
C\_luteolum\_DSM\_273 & PF01507 & NC\_007512.1\_1606 & 5.4e-40 & MSRI... \\ \hline
\end{tabular}%
}
\end{table}

\begin{lstlisting}[language=Python]     
# Retrieve matches only for hits with the lowest E-value
# and for a single step                                   
results.get_step_matches('GenProp1764', 1, top=True)
Out:
\end{lstlisting}

\begin{table}[!ht]
\centering
\resizebox{\textwidth}{!}{%
\begin{tabular}{|l|l|l|l|l|}
\hline
\textbf{Sample\_Name} & \textbf{Signature\_Accession} & \textbf{Protein\_Accession} & \textbf{E-value} & \textbf{Sequence} \\ \hline
C\_chlorochromatii\_CaD3 & PF00994 & NC\_007514.1\_151 & 1.3e-31 & MRAV… \\ \hline
C\_luteolum\_DSM\_273 & PF01507 & NC\_007512.1\_1606 & 5.4e-40 & MSRI... \\ \hline
\end{tabular}%
}
\end{table}

\begin{lstlisting}[language=Python]  
# Retrieve matches only for hits with the lowest E-value 
# for a single property and for only one sample                                     
results.get_property_matches('GenProp1764', 
                           sample='C_chlorochromatii_CaD3',
                           top=True)
Out:
\end{lstlisting}

\begin{table}[!ht]
\centering
\resizebox{\textwidth}{!}{%
\begin{tabular}{|l|l|l|l|l|}
\hline
\textbf{Step\_Number} & \textbf{Signature\_Accession} & \textbf{Protein\_Accession} & \textbf{E-value} & \textbf{Sequence} \\ \hline
1 & PF00994 & NC\_007514.1\_151 & 1.300000e-31 & MRAE... \\ \hline
2 & PF01687 & NC\_007514.1\_1520 & 3.100000e-33 & MRLI... \\ \hline
\end{tabular}%
}
\end{table}

\begin{lstlisting}[language=Python]  
# For a given property step, write the protein 
# that is most likely to carry out the step in each 
# organism. These proteins have the lowest E-value
# for their domain annotation match.                                 
with open('proteins.fasta', 'w') as fasta_file:
    results.write_supporting_proteins_for_step_fasta(fasta_file, 
                                                   'GenProp1757', 
                                                    2, 
                                                    top=True)
\end{lstlisting}

\subsection{AssignmentCacheWithMatches and GenomePropertiesResultsWithMatches Performance}

For two samples consisting of 1877 and 1774 proteins, respectively, it took 80.4 ms \textpm 1.65 ms and 89.4 ms \textpm 4.04 ms to parse the FASTA and InterProScan TSV files and generate two AssignmentCacheWithMatches objects. These caches were then combined into a single GenomePropertyResultsWithMatches object in 4.20 s \textpm 202 ms. The two assignment caches were found to take 21.3 and 15.3 MB of memory, respectively. The final GenomePropertyResultsWithMatches object was found to take up only 29.8 MB of memory. The size of the objects was determined to be sufficient. A first glance GenomePropertyResultsWithMatches object creation appears to take much time. This time spent is likely due the time taken to join the information found inside each AssignmentCacheWithMatches object. Specifically, the time took joining pandas DataFrames. At over 4.2 seconds for joining only two caches, scaling analyses to large datasets may become a challenge and opportunities for optimizing this step should be pursued. The GenomePropertyResultsWithMatches object created above was serialized to JSON in 7.1 s \textpm 1.3 s. This speed was found to be slower than expected and may need to be optimized in the future. The proteins most likely to carry out GenProp1757 step number two in each sample were written to a FASTA file in 21.7 ms \textpm 793 µs using the above GenomePropertyResultsWithMatches's \textbf{write\_supporting\_proteins\_for\_step\_fasta} method (Table \ref{tab:genomepropertyresultswithmatches}). This speed was quite fast and is most likely due to Pygenprop's use of Scikit-bio for FASTA file writing.

\section{Development of a File Storage Format and Database Interface for Storing Genome Property Assignments and Supporting Information} \label{MicromedaFiles}

Once Pygenprop generates assignments of support for individual genome properties and steps, it would be useful to be able to store these assignments for later use or dissemination. With the Genome Properties Perl library, property and step assignments can be saved to text files written in either a custom human-readable format (see \\ \href{github.com/Micromeda/pygenprop/blob/master/pygenprop/testing/test\_constants/C\_chlorochromatii\_CaD3.txt}{github.com/Micromeda/pygenprop/blob/master/pygenprop/testing/test\_constants/ \\ C\_chlorochromatii\_CaD3.txt}) or JSON format. Both of these file types are created per-organism and do not contain supporting information such as annotation match scores or protein sequences. Since the Perl library creates these files per-organism, a large number of records must be tracked and managed if a researcher wants to compare assignments across multiple organisms. Also, if a user wants to retain information about domain annotations and protein sequences that support these assignments, they would have to track and manage a series of additional InterProScan TSV and FASTA files for each organism. Tracking, managing and sharing all these files would be difficult, so Pygenprop supports the creation of Micromeda files that store the information held within these three file types in a single file. This new file type can store data for multiple organisms allowing the transfer of entire datasets between users or computer systems.

\subsection{Selection of a Data Storage Format}

Micromeda's assignment results file format is based on SQLite3 \cite{owens2006definitive}. During Pygenprop's development, several file formats were reviewed before the selection of this format. The types considered included custom text formats, custom binary formats, JSON, YAML and hierarchical Data Format 5 (HDF5). Custom text or binary files were passed over as they would provide minimal advantages over existing off-the-shelf types that offer similar performance with little to no development overhead. Javascript Object Notation (JSON) and Yaml ain't markup language (YAML) \cite{ben2005yaml} were not selected as they are both text encoded files and, though human-readable, take up substantially more disk space than equivalent binary formats. HDF5 \cite{folk2011overview} is a binary format used for storing enormous arrays of data, allowing a user to define data structures inside the file. It is currently used as the data storage format for Oxford Nanopore sequencers, where it is used to store raw signal information from a sequencing run. We chose SQLite3 over HDF5 for the following reasons:
\begin{itemize}
\item It would take less time to design SQLite3 database tables than it would be to define our own custom HDF5 structures
\item SQLite3's compatibility with a broad range of tools and programming languages
\item SQLite3 uses Structured Query Language (SQL) allowing for compatibility with larger server-based database systems such as MySQL \cite{dubois1999mysql} and PostgreSQL \cite{momjian2001postgresql, owens2006definitive}
\end{itemize}

\subsection{The Usage of SQLAlchemy to Provide Expanded Database Connectivity} \label{SQLAlchemy}l

Traditional relational database management systems (DBMS), such as MySQL and PostgreSQL, are server processes that continually run on a computer system (i.e., daemons \cite{martin2006computer}) waiting for input from other programs on the computer or human users \cite{dubois1999mysql, momjian2001postgresql}. They are designed to handle connections from hundreds of applications or users simultaneously, even across computer networks. Users or processes communicate with these DBMSs via a domain-specific language (DSL) called Structured Query Language (SQL) \cite{sql1987guide}. SQL is a standard language that can be used to interact with a verity of DBMSs. It allows a user to define the structure of a database, add and remove data and query data \cite{sql1987guide}. In contrast to traditional databases, SQLite3 does not run as a server process. In contrast, it is a C library and associated file type that takes SQL strings as input and uses it to manipulate a single small file on disk \cite{owens2006definitive}.

It is important to note that the SQL language has been continually updated since the late 1980s \cite{sql1987guide, ISO9075}. Different DBMSs have each implemented various features of the language and have also added new features of the language that are only used by themselves (e.g., new column types). As a result, the SQL written for one DBMS may not be compatible with another. 

SQLAlchemy \cite{bayer2014sqlalchemy} is a tool that acts as a compatibility layer. It allows users to write software that can query and store data in multiple relational DBMSs (Fig. \ref{fig:sqlalchemy}). To preventing incompatibly, SQLAlchemy generates SQL code tailored to each type of DBMS. It also allows the user to define a relational database schema in a series of Python classes, access individual database records as Python objects (Fig. \ref{fig:sqlalchemy}) and query a database using Python idioms. Record objects are used by SQLAlchemy to issue SQL commands to a database, a process known as object-relational mapping \cite{ambler2000mapping,bayer2014sqlalchemy} (see \href{https://en.wikipedia.org/wiki/Object-relational\_mapping}){en.wikipedia.org/wiki/Object-relational\_mapping}) \cite{o2008object}. SQLAlchemy allows a user to create, update, delete and query data from an SQL DBMS without writing a single line in the SQL language \cite{bayer2014sqlalchemy}.

Pygenprop uses SQLAlchemy to write assignment data and supporting match information to SQLite3 files. In the context of Pygenprop, we call these files Micromeda files. Also, due to the use of SQLAlchemy and through the changing of a single line of code, Pygenprop can write assignments and supporting data to more extensive, daemon-based, high-performance databases such as PostgreSQL or MySQL (Fig. \ref{fig:sqlalchemy}). Also, the use of SQLAlchemy allows users to write to clustered versions of these databases, such as Postgres-XL (see \href{www.postgres-xl.org}{postgres-xl.org}), allowing the storage of property assignments for hundreds of thousands of organisms.

\begin{figure}[!ht]
  \centering
	\includegraphics[width=0.65\textwidth]{media/SQLAlchemy.pdf}
	 \caption{SQLAlchemy maps a series of objects generated from an GenomePropertiesResultsWithMatches object to relational database tables.}
	 \label{fig:sqlalchemy}
\end{figure}

\subsection{The Schema of the Micromeda File Format}

As with all relational database schemas, Micromeda's schema consists of a series of data tables. These tables were designed in such a way as to store property assignments, step assignments and associated supporting information compactly as possible. This compactness is essential as it allows users to keep files sizes, and thus transfer times, to a minimum allowing for quick dissemination of datasets. The optimizations that were chosen to support this goal of are listed below:

\begin{itemize}
\item Only retain supporting information for steps that are assigned YES (as discussed in Section \ref{MatchConsiderations})
\item Only retain step assignments that are assigned YES (step assignments of NO are inferred using information from a GenomePropertiesTree object)
\item Property and step assignments of support (i.e. YES, NO, or PARTIAL) are stored as the numbers 0, 1, and 2, rather than strings, to save space
\item The database schema was normalized to the 3rd normal form (3NF) \cite{beeri1989sophisticate} \footnote{Database normalization (see \href{en.wikipedia.org/wiki/Database\_normalization}{en.wikipedia.org/wiki/Database\_normalization}) is the process of splitting large data tables into smaller tables that are linked together and only store each piece of data in the dataset once. For example, a protein only needs to be stored once if it is kept in a separate table. \label{normailization-note}} 
\end{itemize}

Before writing SQLAlchemy classes for relational database tables, a SQL schema for Micromeda SQLite3 files was designed visually in the entity-relationship diagramming software called Vertabelo (see \href{www.vertabelo.com}{vertabelo.com}). During the database design, the data schema was normalized to the third normal form (3NF) \cite{beeri1989sophisticate}. The Micromeda file's final relational table structure can be seen in the schema found in Fig. \ref{fig:micromedaschema}.

\begin{figure}[!ht]
  \centering
	\includegraphics[width=0.50\textwidth]{media/micromeda_schema.pdf}
	 \caption{The SQL schema for Micromeda SQLite3 files contains tables for samples, property assignments, step assignments, a mapping table between step assignments and interpro annotations, interpro annotations and proteins sequences.}
	 \label{fig:micromedaschema}
\end{figure}

\subsection{SQLAlchemy Classes Used By Micromeda} \label{sqlalchemy-classes}

Pygenprop maintains five SQLAlchemy classes for representing relational tables and records. These objects represent individual property assignments, step assignments, InterProScan domain annotations and protein sequences. They are used to generate SQL statements for both creating SQL tables and database queries through SQLAlchemy's object-relational mapping functionality. Attributes and Properties of these objects are detailed in Tables \ref{tab:sampleobject}, \ref{tab:propertyassignmentobject}, \ref{tab:stepassignmentobject}, \ref{tab:interproscanannotationobject}, \ref{tab:sequenceobject}.

\begin{table}[!ht]
\centering
\caption{The attributes of Sample objects.}
\label{tab:sampleobject}
\begin{tabular}{|p{2.7cm}|p{2cm}|p{10cm}|}
\hline
\textbf{Name} & \textbf{Type} & \textbf{Description} \\ \hline
name & Attribute & The name of the sample; for example an organism name \\ \hline
property \_assignments & Attribute & A list of property assignment objects \\ \hline
\end{tabular}
\end{table}

\begin{table}[!ht]
\centering
\caption{The properties and attributes of PropertyAssignment objects.}
\label{tab:propertyassignmentobject}
\begin{tabular}{|p{2.7cm}|p{2cm}|p{10cm}|}
\hline
\textbf{Name} & \textbf{Type} & \textbf{Description} \\ \hline
assignment & Property & Return the property's assignment as YES, NO or PARTIAL \\ \hline
identifier & Property & Return the property's identifier (e.g. GenProp0078) \\ \hline
property \_assignment \_identifier & Attribute & A unique numeric identifier for a property assignment of a single sample \\ \hline
property \_number & Attribute & The genome property identifier as a number (e.g. the 0078 of GenProp0078) \\ \hline
numeric \_assignment & Attribute & The property's assignment as the numbers 0, 1, or 2 (equal to YES, NO or PARTIAL) \\ \hline
sample\_name & Attribute & The name of the sample for that the property assignment belongs to \\ \hline
sample & Attribute & The sample object for that the property assignment belongs to \\ \hline
step \_assignments & Attribute & A list of step assignment objects belonging to a single property \\ \hline
\end{tabular}
\end{table}

\begin{table}[!ht]
\centering
\caption{The attributes of StepAssignment objects.}
\label{tab:stepassignmentobject}
\begin{tabular}{|p{2.7cm}|p{2cm}|p{10cm}|}
\hline
\textbf{Name} & \textbf{Type} & \textbf{Description} \\ \hline
step \_assignment \_identifier & Attribute & A unique numeric identifier for a step assignment of a single sample \\ \hline
property \_assignment \_identifier & Attribute & The genome property identifier for that the step belongs to as a number (e.g. the 0078 of GenProp0078) \\ \hline
number & Attribute & The step's number \\ \hline
property \_assignment & Attribute & The property assignment object for that the step assignment belongs to \\ \hline
interproscan \_matches & Attribute & A list of interproscan match objects that support the existence of property assignment \\ \hline
\end{tabular}
\end{table}

\begin{table}[!ht]
\centering
\caption{The attributes of InterProScanMatch objects.}
\label{tab:interproscanannotationobject}
\begin{tabular}{|p{2.7cm}|p{2cm}|p{10cm}|}
\hline
\textbf{Name} & \textbf{Type} & \textbf{Description} \\ \hline
interproscan \_match \_identifier & Attribute & A unique numeric identifier for an interproscan annotation of a single protein sequence \\ \hline
sequence \_identifier & Attribute & The identifier of a protein sequence \\ \hline
interpro \_signiture & Attribute & The InterPro consortium signature accession of a domain found in a protein sequence \\ \hline
expected\_value & Attribute & The expected value of the match between a motif found in the protein and annotated domain \\ \hline
step \_assignments & Attribute & A list of step assignment objects that are supported by the InterProScan annotation \\ \hline
sequence & Attribute & The sequence object that the InterProScan annotation annotates. \\ \hline
\end{tabular}
\end{table}

\begin{table}[!ht]
\centering
\caption{The attributes of Sequence objects.}
\label{tab:sequenceobject}
\begin{tabular}{|p{2.7cm}|p{2cm}|p{10cm}|}
\hline
\textbf{Name} & \textbf{Type} & \textbf{Description} \\ \hline
identifer & Attribute & The identifier of a protein sequence \\ \hline
sequence & Attribute & The protein sequence of the protein \\ \hline
\end{tabular}
\end{table}

\subsection{Writing Micromeda Files}

Both GenomePropertiesResults and GenomePropertiesResultsWithMatches objects provide a \textbf{to\_assignment\_database} method (Tables \ref{tab:results-object} and \ref{tab:genomepropertyresultswithmatches}). This method takes an SQLAlchemy engine object and uses it to write assignment and annotation information to a database. This engine object is created from a database Universal Resource Indicator (URI) \cite{berners1998uniform} string that can point toward an SQLite3 file or a larger process-based relational database. Once called, this method converts the results object's pandas DataFrames to a series of SQLAlchemy objects and then use SQLAlchemy to write the information contained within these objects to the engine's connected database. Code for writing Micromeda files can be found below.

\begin{lstlisting}[language=Python]  

# A SQLAlchemy engine object can be created
# for a variety of SQL databases

# Write to a Micromeda file
engine = create_engine('sqlite:///data.micro')
results.to_assignment_database(engine)

# Write to a PostgreSQL database
db_uri = 'postgresql://scott:tiger@localhost:5432/mydatabase'
engine2 = engine = create_engine(db_uri)
results.to_assignment_database(engine2)

\end{lstlisting}

\subsection{Reading Micromeda Files}

The reading of assignments from Micromeda files or databases is facilitated by the \textbf{load\\ \_assignment\_caches\_from\_database} and \textbf{load\_assignment\_caches\_from\_database \\ \_with\_matches} functions of Pyegenprop's results module. These functions produce lists of AssignmentCache, or AssignmentCacheWithMatches objects, respectively. These lists can the be combined into GenomePropertiesResults or GenomePropertiesResultsWithMatches objects. Code for reading Micromeda files can be found below.

\begin{lstlisting}[language=Python]  
tree = parse_genome_properties_flat_file(properties_file_handle)
engine = create_engine('sqlite:///data.micro')

caches = load_assignment_caches_from_database_with_matches(engine)

results = GenomePropertiesResultsWithMatches(*caches,          
                                properties_tree=property_tree)
\end{lstlisting}

\subsection{Micromeda File Performance} \label{micromeda-file-performance}

For two samples consisting of 1877 and 1774 proteins, a representative GenomePropertiesResultsWithMatches was generated. This object was found to be able to be serialized to a Micromeda file in 29.4 s \textpm 829 ms. This Micromeda file was found to be approximately one fifth the size of the original files used to create the GenomePropertiesResultsWithMatches objects (Fig. \ref{fig:micromedafilesize}). The same Micromeda file was found to be able to be reconstituted back into GenomePropertiesResultsWithMatches object in 6.28 s \textpm 1.33 s. Although the speed to read Micromeda files was sufficient, writing performance was weak and should be further optimized. Currently, records for individual assignments, annotations and sequences are inserted one at a time into the Micromeda file. Batching these inserts together before writing could further improve Micromeda file writing performance.

\begin{figure}[!ht]
  \centering
	\includegraphics[width=0.80\textwidth]{media/micromeda_file_size.pdf}
	 \caption{Pathway analysis for two samples previously required the tracking of at least six files. With Micromeda the information contained within these files is combined and reduced, allowing for property assignment and supporting information to be stored in a single file and in one filth the disk space.}
	 \label{fig:micromedafilesize}
\end{figure}

\section{Development of an In-Memory Transfer Format for Property Assignments and Supporting Match Information} \label{msgpack}

When writing software for pathway analysis on high-performance computing (HPC) infrastructure, it may be of interest to transfer pathway datasets between machines via memory-to-memory transfers. It may also be useful to be able to store pathway datasets in an in-memory cache to accelerate bioinformatics web application performance. The Micromeda Server uses such a cache (Chapter XXX). GenomePropertyResultsWithMatches objects can be serialized into a format optimized for these use cases. A key performance metric for both of these use cases is serialization/deserialization speed of GenomePropertyResultsWithMatches objects to and from the format. The memory space taken up by the format is less of a concern. The format ultimately chosen was MessagePack  \cite{furuhashi2013messagepack}(see \href{msgpack.org}{msgpack.org}).

\subsection{Selection of MessagePack}

Several formats were reviewed to support memory-to-memory transfer and in-memory caching of GenomePropertyResultsWithMatches objects. These included: JSON, Google Protocol Buffers \cite{varda2008protocol}, and MessagePack. JSON has been the gold standard for transferring information between computer systems, especially over the internet, for over a decade \cite{d4_softwareltd_2017}. Because JSON is a text format, several binary alternatives such as ProtoBuffs and Msgpack have emerged that can store the same amount data in less space, allowing for faster transfers \cite{furuhashi2013messagepack,varda2008protocol,krebs_2017,cooper_2010,bengtsson_24AD}. These formats also have much better serialization performance than JSON \cite{krebs_2017,cooper_2010,bengtsson_24AD}. For Pygenprop, MessagePack was selected over Protocol Buffers since pandas provide built-in methods, though currently experimental, for serializing DataFrames directly to MessagePack. MessagePack also serializes four times faster than Protocol Buffers \cite{cooper_2010}.

\subsection{Serialization and Deserialization of GenomePropertyResultsWithMatches to Msgpack}

GenomePropertyResults and GenomePropertyResultsWithMatches objects have a method called \textbf{to\_msgpack} that supports serialization of these objects to a MessagePack binary string. Internally, this function calls pandas' \textbf{to\_msgpack} function on a list of the object's pandas DataFrames (Tables \ref{tab:results-object} and \ref{tab:genomepropertyresultswithmatches}), returning a MessagePack binary. For deserialization, the process is run in reverse, using the function \textbf{load\_results\_from\_msgpack} of Pygenprop's results module, converting the MessagePack binary stream back to a GenomePropertyResultsWithMatches object. Code for serializing and deserializing GenomePropertyResultsWithMatches objects can be found below.

\begin{lstlisting}[language=Python]  
message = results.to_msgpack()

new_results = load_results_from_msgpack(message)
\end{lstlisting}

\subsection{Msgpack Serialization and Deserialization Performance} \label{messagepack-performance}

For two samples consisting of 1877 and 1774 proteins, a representative GenomePropertiesResultsWithMatches was generated. This object serialized to a msgpack binary in 29.5 ms \textpm 270 µs and and deserialized in 54 ms \textpm 922 µs. The msgpack binary required 4.36 MB of memory. Both the speed of serialization and the memory used by message pack objects was determined to be sufficient. If lower memory usage is required the GenomePropertiesResultsWithMatches object's step matches DataFrame (Table \ref{tab:genomepropertyresultswithmatches}) could be normalized into two DataFrames, one for storing annotation information and another for storing sequencing information. The data in each of these DataFrames, even when added together, would be smaller than the previous step matches DataFrame since values such as sequences will only be stored once.

\section{Verification and Automated Testing}

To validate that property and step assignments of support were calculated correctly, the property and step assignments generated by Pygenprop were compared to those produced by the original Genome Properties Perl library. Based on a test proteome of 3,000 proteins, property assignments differed from those of the original Perl library by approximately 2.9\%, due to an error that we corrected Pygenprop (\href{https://github.com/ebi-pf-team/genome-properties/issues/30}{https://github.com/ebi-pf-team/genome-properties/issues/30}).

The same test proteome, along with a second of similar size, were used to validate that assignments and supporting information did not change before and after serialization of GenomePropertiesResults and GenomePropertiesResultsWithMatches objects. We found that Pygenprop could correctly reconstitute these objects from both SQLite3 files and MessagPack binary strings.

Pygenprop has extensive end-to-end and unit tests for its codebase. There are currently 104 unit tests that validate the functionality of the majority of code functions. These tests cover 94\% of lines in the Pygenprop's codebase. Pygenprop's end-to-end test involves the making of a JSON serialization of a GenomePropertiesResults object created from the InterProScan results of two organisms. This test can be run against newly released versions of the Genome Properties database to ensure compatibility over time. 

\section{Future Improvements}

Although Pygenprop is currently feature-rich and available to the public, there are still several improvements that could be used to make the library more useful. Some of these are related to making it more computationally efficient, whereas others are related to improving its analysis capabilities. Several potential improvements are highlighted below.

\subsection{Adding The Ability To Serialize GenomeProperty Objects to DESC Files}

GenomeProperty objects and their related child objects (see Section \ref{genomeprop-oop}) are designed to represent individual genome properties, their steps, functional elements and evidence. It is currently possible to take a Genome Properties \textbf{DESC} file (see Section \ref{Genome-Properties-Files}) and use Pygenprop to turn its contents into objects, but it is not possible to do the reverse. Being able to serialize a GenomeProperty object and its children to a \textbf{DESC} file may be useful for users who want to add new genome properties to the Genome Properties database. For example, an end-user could use a Jupyter Notebook \cite{kluyver2016jupyter} to create a new genome property iteratively. Additionally, the above functionality would be useful for writing software that could automatically port pathways from other pathway databases such as KEGG \cite{kanehisa2000kegg} to Genome Properties. For example, software scripts could be designed and used to mine InterProScan annotations of KEGG genes \cite{kanehisa2015kegg} to find InterPro domains that support the existence of KEGG pathways that are not yet in the Genome Properties database. Pygenprop could then use these domains to create new genome properties, mirroring the above KEGG pathways, and write their \textbf{DESC} files to a fork of the Genome Properties flat-file database. This fork could later be merged into the official Genome Properties Github repository for use by other users. In the future, the ability to serialize GenomeProperty objects to \textbf{DESC} files should be added.

\subsection{Improving Pygenprop's Memory and Time Performance}

Throughout this chapter, the performances of different components of Pygenprop have been reviewed. Three of these performance numbers were found to be quite weak and should be addressed. These are the time taken the reading and writing Micromeda files and the time required for serializing GenomePropertiesResultsWithMatches objects to JSON. Micromeda's server component uses all three of these functions extensively, and they are a significant source of lag in Micromeda's web interface.

\subsubsection{Increasing the Speed of Reading and Writing Micromeda Files} \label{micromeda-file-improvements}

Currently, when writing Micromeda files, the pandas DataFrames inside of GenomePropertiesResultsWithMatches and GenomePropertiesResults objects are converted to a series of SQLAlchemy objects before writing (Section \ref{Genome-Properties-Files}). These objects are then used to write to the Micromeda file. There is some overhead to this conversion and it may be the source of Pygenprop's poor writing performance. Further investigation will be required to determine if this is true. However, if it is found that there are no good options for speeding up this process, there are alternatives. 

Another way to write Micromeda files, which could be potentially faster, would be to use pandas DataFrame's \textbf{to\_sql} method for writing Results DataFrames directly to the file, instead of using Pygenprop's SQLAlchemy classes. Like the current version of the \textbf{to\_assignment\_database} method of the above Results objects (Table \ref{tab:results-object}), \textbf{to\_sql} also takes an SQLAlchemy engine object and uses SQLAlchemy to write to Micromeda files. However, unlike Pygenprop's implementations, it does not use Object-relational mapping \cite{ambler2000mapping} and only uses certain SQLAlchemy functions to generate raw SQL for writing DataFrames to the file. This method would skip the instantiation of Pygenprop's SQLAlchemy classes (Fig. \ref{fig:sqlalchemy}). The current design of GenomePropertiesResultsWithMatches object's \textbf{step\_matches} DataFrame (Table \ref{tab:genomepropertyresultswithmatches} and Fig. \ref{fig:resultswithmatchescreation}) is not fully normalized (in terms of database normalization as discussed in Footnote \ref{normailization-note}) as sequences are stored multiple times in the DataFrame. If the \textbf{to\_sql} method were to be used, this DataFrame would have to be split into two before writing to keep the resulting Micromeda file's size down. Step assignments that were assigned NO would also have to be dropped from the Result object's \textbf{step\_results} DataFrame before writing. The above writing technique could be run in reverse, using pandas \textbf{read\_sql} function, to transform Micromeda files back into Results objects.

In order to circumvent poor read and write performance of Micromeda files, one option would be to replace SQLite3 as its format. An alternative format with faster serialization could be used instead. For example, the GenomePropertiesResultsWithMatches and GenomePropertiesResults object's existing \textbf{to\_msgpack} function (Table \ref{tab:results-object}) could be used to read and write MessagPack binary strings to and from disk. These binary files could be used as an alternate Micromeda file format. As with the \textbf{to\_sql} method mention above, this technique would also require splitting of the Results object's \textbf{step\_matches} DataFrame and removal of steps assigned NO from its \textbf{step\_results} DataFrame.

Even if SQLite3 is ultimately not used for Micromeda's file format, the SQLAlchemy (Subsection \ref{sqlalchemy-classes}) classes developed for it are still useful. They provide a way to store large numbers of property assignments and supporting information in a process-based relational database such as PostgreSQL and can also be used to query such databases for particular pieces of data, such as individual protein sequence, without needing to reconstitute an entire GenomePropertiesResultsWithMatches object. This querying capability would be useful for analyzing massive datasets.

\subsubsection{Increasing the Speed of JSON Serialization of GenomePropertiesResultsWithMatches} \label{pygenprop-json-serialization}

GenomePropertiesResultsWithMatches and GenomePropertiesResults objects can be serialized to JSON using these object's \textbf{to\_json} method (Table \ref{tab:results-object}). This method produces a JSON string with a tree of genome property nodes, one node for each property in the Genome Properties tree. Each of these genome property nodes is tagged with a list of assignment results (YES, NO, and PARTIAL) for each organism used to create the original Results object. In the current implementation of \textbf{to\_json}, the Results object's \textbf{get\_property\_result} (Table Table \ref{tab:results-object}) method is called during each node's creation. It turns out that this function is quite slow due to a limitation in pandas. During the execution of the \textbf{to\_json} method, this method is called over a thousand times, once for each genome property in the database, slowing down JSON creation substantially.

 The speed of \textbf{to\_json} could be increased in two ways. JSON creation could be sped up by reconfiguring the structure of \textbf{to\_json}'s output. For example, one could move per-organism assignments from each node on the JSON tree to a secondary hash table placed alongside it in the output JSON document. If this was the case, pandas DataFrame's \textbf{to\_json} method could be used to generate such a hash table quite quickly. It is faster to write out the Results object's \textbf{property\_results} DataFrame to JSON all at once rather than write it one property at a time using the \textbf{get\_property\_result} method. If pandas DataFrame's \textbf{to\_json} approach were taken, downstream applications such as Micromeda's client application would have to be modified to accept the resulting new JSON output format.

Python's built-in JSON library is known to be quite slow, and several third-party libraries have been developed to supplement it \cite{krylysov_2015}. These libraries are often written in C and are many times faster \cite{krylysov_2015}. Pygenprop could use one of these libraries, such as orjson (see \href{pypi.org/project/orjson/}{pypi.org/project/orjson/}), to speed up GenomePropertiesResultsWithMatches and GenomePropertiesResults' \textbf{to\_json} method. However, the use of orjson may have minimal effect if the slow down is due to the Results object's \textbf{get\_property\_result} method.  

\subsection{Adding Additional Analysis Functionality to the GenomePropertyResults Class}

The GenomePropertyResults class provides useful methods for comparing property and step assignments across multiple organisms. However, the addition of new methods to this class could further improve Pygenprop's analysis capability. Such methods would be used in Jupyter Notebooks and software applications.

\subsubsection{A Method to Calculate Fold Change in the Presence of Genome Properties and Steps}

The GenomePropertyResults class currently possesses a method called \textbf{get\_results\_summary} (Subsection \ref{tab:results-object}) that is used to summarize the presence and absence of genome property or step assignments across multiple organisms. This method counts the occurrence of YES, NO and PARTIAL assignments for each organism in a dataset. For example, when comparing the virulence properties of \textit{E. coli} K12 and O157:H7 (see \href{github.com/Micromeda/pygenprop/blob/master/docs/source/\_static/tutorial/tutorial.ipynb}{github.com/Micromeda/pygenprop/ \\blob/master/docs/source/\_static/tutorial/tutorial.ipynb}), this method would show users that O157:H7 has more of these properties assigned YES than K12. This increase could be further quantified by adding a \textbf{calculate\_assignment\_fold\_change} method to the GenomePropertyResults class. This method could take the name of a single sample to use as a baseline and, for the other samples, calculate fold changes in the frequency of YES, NO and PARTIAL assignments of support for specific sets of genome properties or steps.

\subsubsection{Methods for Gene Set Enrichment Analysis}

It is theoretically possible to apply Pygenprop to InterProScan annotations of transcriptomic \cite{wang2009rna} or proteomic \cite{phizicky2003protein} datasets. In this use case, methods for the GenomePropertiesResultsWithMatches class could be developed that perform Gene Set Enrichment Analysis (GSEA) \cite{subramanian2005gene}. These methods would use counts of domain annotations that support specific property steps. For example, step domain enrichment counts could be compared between samples representing before and after treatments. These domain enrichment counts could be later used to calculate overall property-level enrichments for biochemical pathways.

\subsubsection{A Method for Generating Statistical Ordination Visualizations}

Statistical ordination techniques such as principal components analysis (PCA), principal coordinates analysis (PCOA) and non-metric multidimensional scaling (NMDS) can be used to group samples based on feature profiles. These ordination techniques are used to generate scatter plots that display groupings of samples; points that are closer together in the plot are more similar. An example of multivariate data would be the presence or absence of support for different genome properties. If ordination plots were generated for property assignments, they would be useful for giving researches an overview of which organisms are closest to each other metabolically. Scikit-learn \cite{pedregosa2011scikit} possess functions for applying the above three ordination techniques to pandas DataFrames, for example the step or assignment DataFrames of GenomePropertyResults objects (Table \ref{tab:results-object}). GenomePropertyResults could receive methods to generate these plots automatically, using scikit-learn, and these plots could be displayed in Jupyter Notebooks.

\section{Summary}

Pygenprop is a Python library for the programmatic utilization of Genome Properties data. It has methods for both the exploration of the Genome Properties database and the property and step assignments of multiple organisms. It also provides ways of accessing the domain annotations and protein sequences that were used to calculate these assignments. Micromeda files can be used to store and transfer entire pathway analysis datasets allowing for increased reproducibility.

When compared to existing pathway analysis libraries, Pygenprop is unique. It is currently the only Genome Properties library written for Python. The previous Genome Properties library was written in Perl. Unlike this library, Pygenprop provides numerous methods for comparing property assignments across multiple organisms. Also, it allows for the creation of Micromeda files, greatly reducing the number of files required for pathway analysis. There are a variety of pathway analysis software libraries written to support either the KEGG \cite{zhang2009kegggraph,posma2013metabonetworks,yu2012clusterprofiler,cock2009biopython} and Metacyc \cite{international} databases. However, the goals of these libraries are either for downloading KEGG information via its web Application Programming Interface (API) \cite{cock2009biopython}, graph visualization of metabolic networks \cite{posma2013metabonetworks} or GSEA \cite{yu2012clusterprofiler}. In terms of analysis functionality, Pygenprop is closest to clusterProfiler \cite{yu2012clusterprofiler}. However, this package is made for the R programming language \cite{rprogman}, whereas Pygenprop is built for Python. None of the above libraries are integrated with Python's Scipy \cite{scipystack} or machine learning ecosystems in the same way as Pygenprop is, nor do they have its automation enabling features such as the tracking of supporting information or the serialization of entire datasets to files, databases or in-memory transfer formats. This level of automation leaves Pygenprop in a unique position to be used for the development of future integrated pathway analysis tools, such as Micromeda.

With regards to Micromeda, Pygenprop provides the backbone to its server component. In this role, it gives Micromeda's pathway visualization application JSON trees of properties and their assignments, JSON strings containing information about individual properties and FASTA files of protein sequences that support the existence property steps across multiple organisms.
